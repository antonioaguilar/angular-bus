{"version":3,"sources":["webpack:///angular-bus.js","webpack:///webpack/bootstrap f211e087aa70ce2b4feb","webpack:///./pubsub.js","webpack:///./index.js","webpack:///./~/kefir/dist/kefir.js","webpack:///(webpack)/buildin/global.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","pegStream","stream","subscriberCount","unpegStream","directory","_source","_channelName","topics","_binding","topicRegex","topic","prevSegment","pattern","split","map","segment","res","join","RegExp","topicComparator","binding","indexOf","ev","rgx","test","getChannel","eventStream","filter","channel","getTopicStream","channelName","cmp","publish","event","timestamp","Date","toISOString","publishEmitter","emit","subscribe","def","SubscriptionDefinition","callback","addWireTap","subscription","observe","data","unsubscribe","reset","end","Kefir","emitter","when","defs","onSuccess","onError","options","dispose","observer","streams","forEach","_options","push","aligned","zip","limited","once","take","stripped","el","apply","this","error","onUnsubscribe","pubsub","angular","config","$provide","decorator","$delegate","constructor","self","bind","sub","arguments","$on","global","factory","createObj","proto","F","extend","target","length","prop","inherit","Child","Parent","concat","a","b","result","j","Array","find","arr","findByPred","pred","cloneArray","input","remove","index","fn","fillArray","contains","slide","cur","next","max","Math","min","offset","callSubscriber","type","ANY","VALUE","ERROR","Dispatcher","_items","_spies","_inLoop","_removedItems","Observable","_dispatcher","_active","_alive","_activating","_logHandlers","_spyHandlers","Stream","Property","_currentEvent","never","neverS","timeBased","mixin","AnonymousStream","wait","_this","_wait","_intervalId","_$onTick","_onTick","_init","_free","_onActivation","setInterval","_onDeactivation","clearInterval","_clear","later","x","S","interval","S$1","sequentially","xs","S$2","fromPoll","S$3","obs","_emitValue","_emitError","_emitEnd","e","_emit","emitEvent","withInterval","S$4","S$5","_fn","_unsubscribe","fromCallback","callbackConsumer","called","setName","fromNodeCallback","spread","aLength","fromSubUnsub","unsub","transformer","handler","fromEvents","eventName","pairs","undefined","Error","P","current","constant","P$1","constantError","createConstructor","BaseClass","source","_name","_$handleAny","_handleAny","createClassMethods","_handleValue","_handleError","_handleEnd","END","onAny","offAny","createStream","createProperty","toProperty","P$2","changes","S$6","fromPromise","promise","onValue","_promise","then","done","getGlodalPromise","Promise","toPromise","last","resolve","reject","createCommonjsModule","fromESObservable","_observable","observable","$$observable","complete","ESObservable","takeErrors","toESObservable","collect","keys","values","defaultErrorsCombinator","errors","latestError","Combine","active","passive","combinator","_activeCount","_sources","_combinator","_aliveCount","_latestValues","_latestErrors","NOTHING","_emitAfterActivation","_endAfterActivation","_latestErrorIndex","_$handlers","combineAsArray","isArray","combineAsObject","activeObservables","passiveObservables","objectify","combine","map$1","id","_ofSameType","S$7","P$3","id$1","S$8","P$4","S$9","P$5","S$10","P$6","takeWhile","id$2","S$11","P$7","S$12","P$8","skip","S$13","P$9","skipWhile","id$3","S$14","P$10","skipDuplicates","eq","S$15","P$11","defaultFn","diff","seed","S$16","P$12","scan","P$13","flatten","S$17","id$4","delay","S$18","P$14","throttle","_ref2","_ref2$leading","leading","_ref2$trailing","trailing","S$19","P$15","debounce","_ref2$immediate","immediate","S$20","P$16","mapErrors","id$5","S$21","P$17","filterErrors","id$6","S$22","P$18","ignoreValues","S$23","P$19","ignoreErrors","S$24","P$20","ignoreEnd","S$25","P$21","beforeEnd","S$26","P$22","slidingWindow","S$27","P$23","bufferWhile","_ref2$flushOnEnd","flushOnEnd","S$28","P$24","id$7","bufferWhile$1","count","S$29","P$25","bufferWithTimeOrCount","S$30","P$26","xformForObs","@@transducer/step","@@transducer/result","transduce","transducer","S$31","P$27","withHandler","S$32","P$28","Zip","sources","_buffers","observables","AbstractPool","_ref","_ref$queueLim","queueLim","_ref$concurLim","concurLim","_ref$drop","drop","_queueLim","_concurLim","_drop","_queue","_curSources","_$handleSubAny","_handleSubAny","_$endHandlers","_currentlyAdding","Merge","_addAll","_initialised","merge","S$33","generator","_generator","_iteration","repeat","concat$1","Pool","FlatMap","_mainEnded","_lastCurrent","_$handleMain","_handleMain","FlatMapErrors","createConstructor$1","primary","secondary","_primary","_secondary","_lastSecondary","_$handleSecondaryAny","_handleSecondaryAny","_$handlePrimaryAny","_handlePrimaryAny","createClassMethods$1","_handlePrimaryValue","_handlePrimaryError","_handlePrimaryEnd","_handleSecondaryValue","_handleSecondaryError","_handleSecondaryEnd","_removeSecondary","createStream$1","createProperty$1","filterBy","S$34","P$29","sampledBy","id2","skipUntilBy","S$35","P$30","takeUntilBy","S$36","P$31","bufferBy","S$37","P$32","bufferWhileBy","S$38","P$33","awaiting","t","f","valuesToErrors","defFn","S$39","P$34","errorsToValues","defFn$1","S$40","P$35","endOnError","S$41","P$36","dissableDeprecationWarnings","DEPRECATION_WARNINGS","warn","msg","console","add","addSpy","removeSpy","dispatch","spies","_i","items","cleanup","_setActive","_on","_off","onEnd","offValue","offError","offEnd","observerOrOnValue","closed","A","B","getType","sourceObs","selfName","log","toString","isCurrent","offLog","handlerIndex","obj","splice","spy","offSpy","_x","_xs","shift","_emitter","_callUnsubscribe","_getInitialCurrent","getInitial","commonjsGlobal","window","ponyfill","symbolObservablePonyfill","root","_Symbol","Symbol","require$$0$1","index$1","_ponyfill","_ponyfill2","default","Function","require$$0","observerOrOnNext","onComplete","_emitIfFull","hasAllValues","hasErrors","valuesCopy","errorsCopy","Observable$1","empty","of","bimap","fnErr","fnVal","ap","obsFn","obsVal","val","chain","flatMap","staticLand","freeze","mixin$1","mixin$2","_n","mixin$3","mixin$4","mixin$5","_lastValue","mixin$6","mixin$7","mixin$8","_prev","mixin$9","_seed","mixin$10","END_MARKER","mixin$11","_buff","_$shiftBuff","setTimeout","now","getTime","mixin$12","_leading","_trailing","_trailingValue","_timeoutId","_endLater","_lastCallTime","_$trailingCall","_trailingCall","curTime","remaining","_cancelTrailing","clearTimeout","mixin$13","_immediate","_lastAttempt","_laterValue","_$later","_later","mixin$14","mixin$15","mixin$16","mixin$17","mixin$18","mixin$19","mixin$20","_max","_min","mixin$21","_flushOnEnd","_flush","mixin$22","_count","mixin$23","mixin$24","_xform","mixin$25","_handler","_isFull","id$8","_add","toObs","_addToCur","_addToQueue","_removeOldest","obss","_this2","_remove","_removeCur","_removeQueue","_subToEnd","_this3","_subscribe","onEndI","_pullQueue","_onEmpty","_isEmpty","_getSource","plug","unplug","_hadNoEvSinceDeact","mixin$26","_","mixin$27","mixin$28","mixin$29","_ref$flushOnEnd","mixin$30","_ref$flushOnChange","flushOnChange","_flushOnChange","mixin$31","convert","mixin$32","mixin$33","bufferWithCount","other","pool","flatMapLatest","flatMapFirst","flatMapConcat","flatMapConcurLimit","limit","flatMapErrors","g","eval"],"mappings":"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","file":"./angular-bus.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Kefir = __webpack_require__(2);\nvar eventStream = void 0;\nvar publishEmitter = void 0;\nvar directory = void 0;\n\nvar SubscriptionDefinition = function SubscriptionDefinition(stream, callback, onError) {\n  this.stream = stream;\n  this.onUnsubscribe = null;\n  this.subscription = stream.observe({ value: function value(ev) {\n      callback(ev.data, ev);\n    }, error: onError });\n  pegStream(stream);\n};\n\nSubscriptionDefinition.prototype.unsubscribe = function () {\n  if (typeof this.onUnsubscribe === 'function') {\n    this.onUnsubscribe();\n  }\n\n  this.subscription.unsubscribe();\n  unpegStream(this.stream);\n};\n\nfunction pegStream(stream) {\n  stream.subscriberCount = stream.subscriberCount ? stream.subscriberCount + 1 : 1;\n}\n\nfunction unpegStream(stream) {\n  if (! --stream.subscriberCount) {\n    delete directory[stream._source._channelName].topics[stream._binding];\n  }\n}\n\nfunction topicRegex(topic) {\n  var prevSegment = void 0;\n  var pattern = '^' + topic.split('.').map(function mapTopicBinding(segment) {\n    var res = '';\n    if (!!prevSegment) {\n      res = prevSegment !== '#' ? '\\\\.\\\\b' : '\\\\b';\n    }\n    if (segment === '#') {\n      res += '[\\\\s\\\\S]*';\n    } else if (segment === '*') {\n      res += '[^.]+';\n    } else {\n      res += segment;\n    }\n    prevSegment = segment;\n    return res;\n  }).join('') + '$';\n  return new RegExp(pattern);\n}\n\nfunction topicComparator(binding) {\n  if (binding.indexOf('#') === -1 && binding.indexOf('*') === -1) {\n    return function (ev) {\n      return ev.topic === binding;\n    };\n  } else {\n    var rgx = topicRegex(binding);\n    return function (ev) {\n      return rgx.test(ev.topic);\n    };\n  }\n}\n\nfunction getChannel(name) {\n  if (!directory[name]) {\n    directory[name] = {\n      stream: eventStream.filter(function (ev) {\n        return ev.channel === name;\n      }),\n      topics: {}\n    };\n    directory[name].stream._channelName = name;\n  }\n  return directory[name];\n}\n\nfunction getTopicStream(channelName, binding) {\n  var channel = getChannel(channelName);\n  var cmp = topicComparator(binding);\n  var stream = channel.topics[binding] || (channel.topics[binding] = channel.stream.filter(function (ev) {\n    return cmp(ev);\n  }));\n  stream._binding = binding;\n  return stream;\n}\n\nfunction publish(event) {\n  event.timestamp = new Date().toISOString();\n  publishEmitter && publishEmitter.emit(event);\n}\n\nfunction subscribe(def) {\n  return new SubscriptionDefinition(getTopicStream(def.channel, def.topic), def.callback);\n}\n\nfunction addWireTap(callback) {\n  var subscription = eventStream.observe({ value: function value(ev) {\n      callback(ev.data, ev);\n    } });\n  return function () {\n    subscription.unsubscribe();\n  };\n}\n\nfunction reset() {\n  directory = {};\n  publishEmitter && publishEmitter.end();\n  publishEmitter = null;\n  eventStream = Kefir.stream(function (emitter) {\n    publishEmitter = emitter;\n    return function () {\n      publishEmitter = null;\n    };\n  });\n}\n\nfunction when(defs, onSuccess, onError, options) {\n  var streams = [];\n  var _options = options || {};\n  defs.forEach(function (def) {\n    var stream = getTopicStream(def.channel, def.topic);\n    pegStream(stream);\n    streams.push(stream);\n  });\n  var aligned = Kefir.zip(streams);\n  var limited = _options.once ? aligned.take(1) : aligned;\n  var stripped = limited.map(function (data) {\n    return data.map(function (el) {\n      return el.data;\n    });\n  });\n  var observer = stripped.observe({ value: function value(data) {\n      onSuccess.apply(this, data);\n    }, error: onError, end: dispose });\n\n  function dispose() {\n    observer.unsubscribe();\n    streams.forEach(function (stream) {\n      unpegStream(stream);\n    });\n    streams = [];\n  }\n\n  return dispose;\n}\n\nreset();\n\nmodule.exports = {\n  publish: publish,\n  subscribe: subscribe,\n  addWireTap: addWireTap,\n  reset: reset,\n  when: when\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Bind pubsub to Angular root scope as $event property\n(function () {\n  var pubsub = __webpack_require__(0);\n  angular.module('ngBus', []).config([\"$provide\", function ($provide) {\n    $provide.decorator('$rootScope', [\"$delegate\", function ($delegate) {\n      Object.defineProperty($delegate.constructor.prototype, '$event', {\n        get: function get() {\n          var self = this;\n          return {\n            when: pubsub.when.bind(pubsub),\n            publish: pubsub.publish.bind(pubsub),\n            subscribe: function subscribe() {\n              var sub = pubsub.subscribe.apply(pubsub, arguments);\n              sub.onUnsubscribe = self.$on('$destroy', function () {\n                sub.unsubscribe();\n              });\n              return sub;\n            },\n            addWireTap: pubsub.addWireTap.bind(pubsub),\n            reset: pubsub.reset\n          };\n        },\n        enumerable: false\n      });\n      return $delegate;\n    }]);\n  }]);\n})();\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/*! Kefir.js v3.7.1\n *  https://github.com/rpominov/kefir\n */\n\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Kefir = global.Kefir || {})));\n}(this, function (exports) { 'use strict';\n\n\tfunction createObj(proto) {\n\t  var F = function () {};\n\t  F.prototype = proto;\n\t  return new F();\n\t}\n\n\tfunction extend(target /*, mixin1, mixin2...*/) {\n\t  var length = arguments.length,\n\t      i = void 0,\n\t      prop = void 0;\n\t  for (i = 1; i < length; i++) {\n\t    for (prop in arguments[i]) {\n\t      target[prop] = arguments[i][prop];\n\t    }\n\t  }\n\t  return target;\n\t}\n\n\tfunction inherit(Child, Parent /*, mixin1, mixin2...*/) {\n\t  var length = arguments.length,\n\t      i = void 0;\n\t  Child.prototype = createObj(Parent.prototype);\n\t  Child.prototype.constructor = Child;\n\t  for (i = 2; i < length; i++) {\n\t    extend(Child.prototype, arguments[i]);\n\t  }\n\t  return Child;\n\t}\n\n\tvar NOTHING = ['<nothing>'];\n\tvar END = 'end';\n\tvar VALUE = 'value';\n\tvar ERROR = 'error';\n\tvar ANY = 'any';\n\n\tfunction concat(a, b) {\n\t  var result = void 0,\n\t      length = void 0,\n\t      i = void 0,\n\t      j = void 0;\n\t  if (a.length === 0) {\n\t    return b;\n\t  }\n\t  if (b.length === 0) {\n\t    return a;\n\t  }\n\t  j = 0;\n\t  result = new Array(a.length + b.length);\n\t  length = a.length;\n\t  for (i = 0; i < length; i++, j++) {\n\t    result[j] = a[i];\n\t  }\n\t  length = b.length;\n\t  for (i = 0; i < length; i++, j++) {\n\t    result[j] = b[i];\n\t  }\n\t  return result;\n\t}\n\n\tfunction find(arr, value) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    if (arr[i] === value) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction findByPred(arr, pred) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    if (pred(arr[i])) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction cloneArray(input) {\n\t  var length = input.length,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    result[i] = input[i];\n\t  }\n\t  return result;\n\t}\n\n\tfunction remove(input, index) {\n\t  var length = input.length,\n\t      result = void 0,\n\t      i = void 0,\n\t      j = void 0;\n\t  if (index >= 0 && index < length) {\n\t    if (length === 1) {\n\t      return [];\n\t    } else {\n\t      result = new Array(length - 1);\n\t      for (i = 0, j = 0; i < length; i++) {\n\t        if (i !== index) {\n\t          result[j] = input[i];\n\t          j++;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t  } else {\n\t    return input;\n\t  }\n\t}\n\n\tfunction map(input, fn) {\n\t  var length = input.length,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    result[i] = fn(input[i]);\n\t  }\n\t  return result;\n\t}\n\n\tfunction forEach(arr, fn) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    fn(arr[i]);\n\t  }\n\t}\n\n\tfunction fillArray(arr, value) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    arr[i] = value;\n\t  }\n\t}\n\n\tfunction contains(arr, value) {\n\t  return find(arr, value) !== -1;\n\t}\n\n\tfunction slide(cur, next, max) {\n\t  var length = Math.min(max, cur.length + 1),\n\t      offset = cur.length - length + 1,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = offset; i < length; i++) {\n\t    result[i - offset] = cur[i];\n\t  }\n\t  result[length - 1] = next;\n\t  return result;\n\t}\n\n\tfunction callSubscriber(type, fn, event) {\n\t  if (type === ANY) {\n\t    fn(event);\n\t  } else if (type === event.type) {\n\t    if (type === VALUE || type === ERROR) {\n\t      fn(event.value);\n\t    } else {\n\t      fn();\n\t    }\n\t  }\n\t}\n\n\tfunction Dispatcher() {\n\t  this._items = [];\n\t  this._spies = [];\n\t  this._inLoop = 0;\n\t  this._removedItems = null;\n\t}\n\n\textend(Dispatcher.prototype, {\n\t  add: function (type, fn) {\n\t    this._items = concat(this._items, [{ type: type, fn: fn }]);\n\t    return this._items.length;\n\t  },\n\t  remove: function (type, fn) {\n\t    var index = findByPred(this._items, function (x) {\n\t      return x.type === type && x.fn === fn;\n\t    });\n\n\t    // if we're currently in a notification loop,\n\t    // remember this subscriber was removed\n\t    if (this._inLoop !== 0 && index !== -1) {\n\t      if (this._removedItems === null) {\n\t        this._removedItems = [];\n\t      }\n\t      this._removedItems.push(this._items[index]);\n\t    }\n\n\t    this._items = remove(this._items, index);\n\t    return this._items.length;\n\t  },\n\t  addSpy: function (fn) {\n\t    this._spies = concat(this._spies, [fn]);\n\t    return this._spies.length;\n\t  },\n\n\n\t  // Because spies are only ever a function that perform logging as\n\t  // their only side effect, we don't need the same complicated\n\t  // removal logic like in remove()\n\t  removeSpy: function (fn) {\n\t    this._spies = remove(this._spies, this._spies.indexOf(fn));\n\t    return this._spies.length;\n\t  },\n\t  dispatch: function (event) {\n\t    this._inLoop++;\n\t    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n\t      spies[i](event);\n\t    }\n\n\t    for (var _i = 0, items = this._items; _i < items.length; _i++) {\n\n\t      // cleanup was called\n\t      if (this._items === null) {\n\t        break;\n\t      }\n\n\t      // this subscriber was removed\n\t      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {\n\t        continue;\n\t      }\n\n\t      callSubscriber(items[_i].type, items[_i].fn, event);\n\t    }\n\t    this._inLoop--;\n\t    if (this._inLoop === 0) {\n\t      this._removedItems = null;\n\t    }\n\t  },\n\t  cleanup: function () {\n\t    this._items = null;\n\t    this._spies = null;\n\t  }\n\t});\n\n\tfunction Observable() {\n\t  this._dispatcher = new Dispatcher();\n\t  this._active = false;\n\t  this._alive = true;\n\t  this._activating = false;\n\t  this._logHandlers = null;\n\t  this._spyHandlers = null;\n\t}\n\n\textend(Observable.prototype, {\n\n\t  _name: 'observable',\n\n\t  _onActivation: function () {},\n\t  _onDeactivation: function () {},\n\t  _setActive: function (active) {\n\t    if (this._active !== active) {\n\t      this._active = active;\n\t      if (active) {\n\t        this._activating = true;\n\t        this._onActivation();\n\t        this._activating = false;\n\t      } else {\n\t        this._onDeactivation();\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    this._setActive(false);\n\t    this._dispatcher.cleanup();\n\t    this._dispatcher = null;\n\t    this._logHandlers = null;\n\t  },\n\t  _emit: function (type, x) {\n\t    switch (type) {\n\t      case VALUE:\n\t        return this._emitValue(x);\n\t      case ERROR:\n\t        return this._emitError(x);\n\t      case END:\n\t        return this._emitEnd();\n\t    }\n\t  },\n\t  _emitValue: function (value) {\n\t    if (this._alive) {\n\t      this._dispatcher.dispatch({ type: VALUE, value: value });\n\t    }\n\t  },\n\t  _emitError: function (value) {\n\t    if (this._alive) {\n\t      this._dispatcher.dispatch({ type: ERROR, value: value });\n\t    }\n\t  },\n\t  _emitEnd: function () {\n\t    if (this._alive) {\n\t      this._alive = false;\n\t      this._dispatcher.dispatch({ type: END });\n\t      this._clear();\n\t    }\n\t  },\n\t  _on: function (type, fn) {\n\t    if (this._alive) {\n\t      this._dispatcher.add(type, fn);\n\t      this._setActive(true);\n\t    } else {\n\t      callSubscriber(type, fn, { type: END });\n\t    }\n\t    return this;\n\t  },\n\t  _off: function (type, fn) {\n\t    if (this._alive) {\n\t      var count = this._dispatcher.remove(type, fn);\n\t      if (count === 0) {\n\t        this._setActive(false);\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  onValue: function (fn) {\n\t    return this._on(VALUE, fn);\n\t  },\n\t  onError: function (fn) {\n\t    return this._on(ERROR, fn);\n\t  },\n\t  onEnd: function (fn) {\n\t    return this._on(END, fn);\n\t  },\n\t  onAny: function (fn) {\n\t    return this._on(ANY, fn);\n\t  },\n\t  offValue: function (fn) {\n\t    return this._off(VALUE, fn);\n\t  },\n\t  offError: function (fn) {\n\t    return this._off(ERROR, fn);\n\t  },\n\t  offEnd: function (fn) {\n\t    return this._off(END, fn);\n\t  },\n\t  offAny: function (fn) {\n\t    return this._off(ANY, fn);\n\t  },\n\t  observe: function (observerOrOnValue, onError, onEnd) {\n\t    var _this = this;\n\t    var closed = false;\n\n\t    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;\n\n\t    var handler = function (event) {\n\t      if (event.type === END) {\n\t        closed = true;\n\t      }\n\t      if (event.type === VALUE && observer.value) {\n\t        observer.value(event.value);\n\t      } else if (event.type === ERROR && observer.error) {\n\t        observer.error(event.value);\n\t      } else if (event.type === END && observer.end) {\n\t        observer.end(event.value);\n\t      }\n\t    };\n\n\t    this.onAny(handler);\n\n\t    return {\n\t      unsubscribe: function () {\n\t        if (!closed) {\n\t          _this.offAny(handler);\n\t          closed = true;\n\t        }\n\t      },\n\n\t      get closed() {\n\t        return closed;\n\t      }\n\t    };\n\t  },\n\n\n\t  // A and B must be subclasses of Stream and Property (order doesn't matter)\n\t  _ofSameType: function (A, B) {\n\t    return A.prototype.getType() === this.getType() ? A : B;\n\t  },\n\t  setName: function (sourceObs /* optional */, selfName) {\n\t    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n\t    return this;\n\t  },\n\t  log: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\n\t    var isCurrent = void 0;\n\t    var handler = function (event) {\n\t      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n\t      if (event.type === END) {\n\t        console.log(name, type);\n\t      } else {\n\t        console.log(name, type, event.value);\n\t      }\n\t    };\n\n\t    if (this._alive) {\n\t      if (!this._logHandlers) {\n\t        this._logHandlers = [];\n\t      }\n\t      this._logHandlers.push({ name: name, handler: handler });\n\t    }\n\n\t    isCurrent = true;\n\t    this.onAny(handler);\n\t    isCurrent = false;\n\n\t    return this;\n\t  },\n\t  offLog: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\n\t    if (this._logHandlers) {\n\t      var handlerIndex = findByPred(this._logHandlers, function (obj) {\n\t        return obj.name === name;\n\t      });\n\t      if (handlerIndex !== -1) {\n\t        this.offAny(this._logHandlers[handlerIndex].handler);\n\t        this._logHandlers.splice(handlerIndex, 1);\n\t      }\n\t    }\n\n\t    return this;\n\t  },\n\t  spy: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\t    var handler = function (event) {\n\t      var type = '<' + event.type + '>';\n\t      if (event.type === END) {\n\t        console.log(name, type);\n\t      } else {\n\t        console.log(name, type, event.value);\n\t      }\n\t    };\n\t    if (this._alive) {\n\t      if (!this._spyHandlers) {\n\t        this._spyHandlers = [];\n\t      }\n\t      this._spyHandlers.push({ name: name, handler: handler });\n\t      this._dispatcher.addSpy(handler);\n\t    }\n\t    return this;\n\t  },\n\t  offSpy: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\t    if (this._spyHandlers) {\n\t      var handlerIndex = findByPred(this._spyHandlers, function (obj) {\n\t        return obj.name === name;\n\t      });\n\t      if (handlerIndex !== -1) {\n\t        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n\t        this._spyHandlers.splice(handlerIndex, 1);\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t});\n\n\t// extend() can't handle `toString` in IE8\n\tObservable.prototype.toString = function () {\n\t  return '[' + this._name + ']';\n\t};\n\n\tfunction Stream() {\n\t  Observable.call(this);\n\t}\n\n\tinherit(Stream, Observable, {\n\n\t  _name: 'stream',\n\n\t  getType: function () {\n\t    return 'stream';\n\t  }\n\t});\n\n\tfunction Property() {\n\t  Observable.call(this);\n\t  this._currentEvent = null;\n\t}\n\n\tinherit(Property, Observable, {\n\n\t  _name: 'property',\n\n\t  _emitValue: function (value) {\n\t    if (this._alive) {\n\t      this._currentEvent = { type: VALUE, value: value };\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: VALUE, value: value });\n\t      }\n\t    }\n\t  },\n\t  _emitError: function (value) {\n\t    if (this._alive) {\n\t      this._currentEvent = { type: ERROR, value: value };\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: ERROR, value: value });\n\t      }\n\t    }\n\t  },\n\t  _emitEnd: function () {\n\t    if (this._alive) {\n\t      this._alive = false;\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: END });\n\t      }\n\t      this._clear();\n\t    }\n\t  },\n\t  _on: function (type, fn) {\n\t    if (this._alive) {\n\t      this._dispatcher.add(type, fn);\n\t      this._setActive(true);\n\t    }\n\t    if (this._currentEvent !== null) {\n\t      callSubscriber(type, fn, this._currentEvent);\n\t    }\n\t    if (!this._alive) {\n\t      callSubscriber(type, fn, { type: END });\n\t    }\n\t    return this;\n\t  },\n\t  getType: function () {\n\t    return 'property';\n\t  }\n\t});\n\n\tvar neverS = new Stream();\n\tneverS._emitEnd();\n\tneverS._name = 'never';\n\n\tfunction never() {\n\t  return neverS;\n\t}\n\n\tfunction timeBased(mixin) {\n\n\t  function AnonymousStream(wait, options) {\n\t    var _this = this;\n\n\t    Stream.call(this);\n\t    this._wait = wait;\n\t    this._intervalId = null;\n\t    this._$onTick = function () {\n\t      return _this._onTick();\n\t    };\n\t    this._init(options);\n\t  }\n\n\t  inherit(AnonymousStream, Stream, {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _onTick: function () {},\n\t    _onActivation: function () {\n\t      this._intervalId = setInterval(this._$onTick, this._wait);\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._intervalId !== null) {\n\t        clearInterval(this._intervalId);\n\t        this._intervalId = null;\n\t      }\n\t    },\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._$onTick = null;\n\t      this._free();\n\t    }\n\t  }, mixin);\n\n\t  return AnonymousStream;\n\t}\n\n\tvar S = timeBased({\n\n\t  _name: 'later',\n\n\t  _init: function (_ref) {\n\t    var x = _ref.x;\n\n\t    this._x = x;\n\t  },\n\t  _free: function () {\n\t    this._x = null;\n\t  },\n\t  _onTick: function () {\n\t    this._emitValue(this._x);\n\t    this._emitEnd();\n\t  }\n\t});\n\n\tfunction later(wait, x) {\n\t  return new S(wait, { x: x });\n\t}\n\n\tvar S$1 = timeBased({\n\n\t  _name: 'interval',\n\n\t  _init: function (_ref) {\n\t    var x = _ref.x;\n\n\t    this._x = x;\n\t  },\n\t  _free: function () {\n\t    this._x = null;\n\t  },\n\t  _onTick: function () {\n\t    this._emitValue(this._x);\n\t  }\n\t});\n\n\tfunction interval(wait, x) {\n\t  return new S$1(wait, { x: x });\n\t}\n\n\tvar S$2 = timeBased({\n\n\t  _name: 'sequentially',\n\n\t  _init: function (_ref) {\n\t    var xs = _ref.xs;\n\n\t    this._xs = cloneArray(xs);\n\t  },\n\t  _free: function () {\n\t    this._xs = null;\n\t  },\n\t  _onTick: function () {\n\t    if (this._xs.length === 1) {\n\t      this._emitValue(this._xs[0]);\n\t      this._emitEnd();\n\t    } else {\n\t      this._emitValue(this._xs.shift());\n\t    }\n\t  }\n\t});\n\n\tfunction sequentially(wait, xs) {\n\t  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n\t}\n\n\tvar S$3 = timeBased({\n\n\t  _name: 'fromPoll',\n\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _onTick: function () {\n\t    var fn = this._fn;\n\t    this._emitValue(fn());\n\t  }\n\t});\n\n\tfunction fromPoll(wait, fn) {\n\t  return new S$3(wait, { fn: fn });\n\t}\n\n\tfunction emitter(obs) {\n\n\t  function value(x) {\n\t    obs._emitValue(x);\n\t    return obs._active;\n\t  }\n\n\t  function error(x) {\n\t    obs._emitError(x);\n\t    return obs._active;\n\t  }\n\n\t  function end() {\n\t    obs._emitEnd();\n\t    return obs._active;\n\t  }\n\n\t  function event(e) {\n\t    obs._emit(e.type, e.value);\n\t    return obs._active;\n\t  }\n\n\t  return {\n\t    value: value,\n\t    error: error,\n\t    end: end,\n\t    event: event,\n\n\t    // legacy\n\t    emit: value,\n\t    emitEvent: event\n\t  };\n\t}\n\n\tvar S$4 = timeBased({\n\n\t  _name: 'withInterval',\n\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t    this._emitter = emitter(this);\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._emitter = null;\n\t  },\n\t  _onTick: function () {\n\t    var fn = this._fn;\n\t    fn(this._emitter);\n\t  }\n\t});\n\n\tfunction withInterval(wait, fn) {\n\t  return new S$4(wait, { fn: fn });\n\t}\n\n\tfunction S$5(fn) {\n\t  Stream.call(this);\n\t  this._fn = fn;\n\t  this._unsubscribe = null;\n\t}\n\n\tinherit(S$5, Stream, {\n\n\t  _name: 'stream',\n\n\t  _onActivation: function () {\n\t    var fn = this._fn;\n\t    var unsubscribe = fn(emitter(this));\n\t    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\n\t    // fix https://github.com/rpominov/kefir/issues/35\n\t    if (!this._active) {\n\t      this._callUnsubscribe();\n\t    }\n\t  },\n\t  _callUnsubscribe: function () {\n\t    if (this._unsubscribe !== null) {\n\t      this._unsubscribe();\n\t      this._unsubscribe = null;\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    this._callUnsubscribe();\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._fn = null;\n\t  }\n\t});\n\n\tfunction stream(fn) {\n\t  return new S$5(fn);\n\t}\n\n\tfunction fromCallback(callbackConsumer) {\n\n\t  var called = false;\n\n\t  return stream(function (emitter) {\n\n\t    if (!called) {\n\t      callbackConsumer(function (x) {\n\t        emitter.emit(x);\n\t        emitter.end();\n\t      });\n\t      called = true;\n\t    }\n\t  }).setName('fromCallback');\n\t}\n\n\tfunction fromNodeCallback(callbackConsumer) {\n\n\t  var called = false;\n\n\t  return stream(function (emitter) {\n\n\t    if (!called) {\n\t      callbackConsumer(function (error, x) {\n\t        if (error) {\n\t          emitter.error(error);\n\t        } else {\n\t          emitter.emit(x);\n\t        }\n\t        emitter.end();\n\t      });\n\t      called = true;\n\t    }\n\t  }).setName('fromNodeCallback');\n\t}\n\n\tfunction spread(fn, length) {\n\t  switch (length) {\n\t    case 0:\n\t      return function () {\n\t        return fn();\n\t      };\n\t    case 1:\n\t      return function (a) {\n\t        return fn(a[0]);\n\t      };\n\t    case 2:\n\t      return function (a) {\n\t        return fn(a[0], a[1]);\n\t      };\n\t    case 3:\n\t      return function (a) {\n\t        return fn(a[0], a[1], a[2]);\n\t      };\n\t    case 4:\n\t      return function (a) {\n\t        return fn(a[0], a[1], a[2], a[3]);\n\t      };\n\t    default:\n\t      return function (a) {\n\t        return fn.apply(null, a);\n\t      };\n\t  }\n\t}\n\n\tfunction apply(fn, c, a) {\n\t  var aLength = a ? a.length : 0;\n\t  if (c == null) {\n\t    switch (aLength) {\n\t      case 0:\n\t        return fn();\n\t      case 1:\n\t        return fn(a[0]);\n\t      case 2:\n\t        return fn(a[0], a[1]);\n\t      case 3:\n\t        return fn(a[0], a[1], a[2]);\n\t      case 4:\n\t        return fn(a[0], a[1], a[2], a[3]);\n\t      default:\n\t        return fn.apply(null, a);\n\t    }\n\t  } else {\n\t    switch (aLength) {\n\t      case 0:\n\t        return fn.call(c);\n\t      default:\n\t        return fn.apply(c, a);\n\t    }\n\t  }\n\t}\n\n\tfunction fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n\t  return stream(function (emitter) {\n\n\t    var handler = transformer ? function () {\n\t      emitter.emit(apply(transformer, this, arguments));\n\t    } : function (x) {\n\t      emitter.emit(x);\n\t    };\n\n\t    sub(handler);\n\t    return function () {\n\t      return unsub(handler);\n\t    };\n\t  }).setName('fromSubUnsub');\n\t}\n\n\tvar pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\n\tfunction fromEvents(target, eventName, transformer) {\n\t  var sub = void 0,\n\t      unsub = void 0;\n\n\t  for (var i = 0; i < pairs.length; i++) {\n\t    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n\t      sub = pairs[i][0];\n\t      unsub = pairs[i][1];\n\t      break;\n\t    }\n\t  }\n\n\t  if (sub === undefined) {\n\t    throw new Error('target don\\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n\t  }\n\n\t  return fromSubUnsub(function (handler) {\n\t    return target[sub](eventName, handler);\n\t  }, function (handler) {\n\t    return target[unsub](eventName, handler);\n\t  }, transformer).setName('fromEvents');\n\t}\n\n\t// HACK:\n\t//   We don't call parent Class constructor, but instead putting all necessary\n\t//   properties into prototype to simulate ended Property\n\t//   (see Propperty and Observable classes).\n\n\tfunction P(value) {\n\t  this._currentEvent = { type: 'value', value: value, current: true };\n\t}\n\n\tinherit(P, Property, {\n\t  _name: 'constant',\n\t  _active: false,\n\t  _activating: false,\n\t  _alive: false,\n\t  _dispatcher: null,\n\t  _logHandlers: null\n\t});\n\n\tfunction constant(x) {\n\t  return new P(x);\n\t}\n\n\t// HACK:\n\t//   We don't call parent Class constructor, but instead putting all necessary\n\t//   properties into prototype to simulate ended Property\n\t//   (see Propperty and Observable classes).\n\n\tfunction P$1(value) {\n\t  this._currentEvent = { type: 'error', value: value, current: true };\n\t}\n\n\tinherit(P$1, Property, {\n\t  _name: 'constantError',\n\t  _active: false,\n\t  _activating: false,\n\t  _alive: false,\n\t  _dispatcher: null,\n\t  _logHandlers: null\n\t});\n\n\tfunction constantError(x) {\n\t  return new P$1(x);\n\t}\n\n\tfunction createConstructor(BaseClass, name) {\n\t  return function AnonymousObservable(source, options) {\n\t    var _this = this;\n\n\t    BaseClass.call(this);\n\t    this._source = source;\n\t    this._name = source._name + '.' + name;\n\t    this._init(options);\n\t    this._$handleAny = function (event) {\n\t      return _this._handleAny(event);\n\t    };\n\t  };\n\t}\n\n\tfunction createClassMethods(BaseClass) {\n\t  return {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _handleValue: function (x) {\n\t      this._emitValue(x);\n\t    },\n\t    _handleError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handleEnd: function () {\n\t      this._emitEnd();\n\t    },\n\t    _handleAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handleValue(event.value);\n\t        case ERROR:\n\t          return this._handleError(event.value);\n\t        case END:\n\t          return this._handleEnd();\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      this._source.onAny(this._$handleAny);\n\t    },\n\t    _onDeactivation: function () {\n\t      this._source.offAny(this._$handleAny);\n\t    },\n\t    _clear: function () {\n\t      BaseClass.prototype._clear.call(this);\n\t      this._source = null;\n\t      this._$handleAny = null;\n\t      this._free();\n\t    }\n\t  };\n\t}\n\n\tfunction createStream(name, mixin) {\n\t  var S = createConstructor(Stream, name);\n\t  inherit(S, Stream, createClassMethods(Stream), mixin);\n\t  return S;\n\t}\n\n\tfunction createProperty(name, mixin) {\n\t  var P = createConstructor(Property, name);\n\t  inherit(P, Property, createClassMethods(Property), mixin);\n\t  return P;\n\t}\n\n\tvar P$2 = createProperty('toProperty', {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._getInitialCurrent = fn;\n\t  },\n\t  _onActivation: function () {\n\t    if (this._getInitialCurrent !== null) {\n\t      var getInitial = this._getInitialCurrent;\n\t      this._emitValue(getInitial());\n\t    }\n\t    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t  }\n\t});\n\n\tfunction toProperty(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t  if (fn !== null && typeof fn !== 'function') {\n\t    throw new Error('You should call toProperty() with a function or no arguments.');\n\t  }\n\t  return new P$2(obs, { fn: fn });\n\t}\n\n\tvar S$6 = createStream('changes', {\n\t  _handleValue: function (x) {\n\t    if (!this._activating) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleError: function (x) {\n\t    if (!this._activating) {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t});\n\n\tfunction changes(obs) {\n\t  return new S$6(obs);\n\t}\n\n\tfunction fromPromise(promise) {\n\n\t  var called = false;\n\n\t  var result = stream(function (emitter) {\n\t    if (!called) {\n\t      var onValue = function (x) {\n\t        emitter.emit(x);\n\t        emitter.end();\n\t      };\n\t      var onError = function (x) {\n\t        emitter.error(x);\n\t        emitter.end();\n\t      };\n\t      var _promise = promise.then(onValue, onError);\n\n\t      // prevent libraries like 'Q' or 'when' from swallowing exceptions\n\t      if (_promise && typeof _promise.done === 'function') {\n\t        _promise.done();\n\t      }\n\n\t      called = true;\n\t    }\n\t  });\n\n\t  return toProperty(result, null).setName('fromPromise');\n\t}\n\n\tfunction getGlodalPromise() {\n\t  if (typeof Promise === 'function') {\n\t    return Promise;\n\t  } else {\n\t    throw new Error('There isn\\'t default Promise, use shim or parameter');\n\t  }\n\t}\n\n\tfunction toPromise (obs) {\n\t  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();\n\n\t  var last = null;\n\t  return new Promise(function (resolve, reject) {\n\t    obs.onAny(function (event) {\n\t      if (event.type === END && last !== null) {\n\t        (last.type === VALUE ? resolve : reject)(last.value);\n\t        last = null;\n\t      } else {\n\t        last = event;\n\t      }\n\t    });\n\t  });\n\t}\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar ponyfill = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports['default'] = symbolObservablePonyfill;\n\tfunction symbolObservablePonyfill(root) {\n\t\tvar result;\n\t\tvar _Symbol = root.Symbol;\n\n\t\tif (typeof _Symbol === 'function') {\n\t\t\tif (_Symbol.observable) {\n\t\t\t\tresult = _Symbol.observable;\n\t\t\t} else {\n\t\t\t\tresult = _Symbol('observable');\n\t\t\t\t_Symbol.observable = result;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = '@@observable';\n\t\t}\n\n\t\treturn result;\n\t};\n\t});\n\n\tvar require$$0$1 = (ponyfill && typeof ponyfill === 'object' && 'default' in ponyfill ? ponyfill['default'] : ponyfill);\n\n\tvar index$1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _ponyfill = require$$0$1;\n\n\tvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\n\tfunction _interopRequireDefault(obj) {\n\t  return obj && obj.__esModule ? obj : { 'default': obj };\n\t}\n\n\tvar root; /* global window */\n\n\tif (typeof self !== 'undefined') {\n\t  root = self;\n\t} else if (typeof window !== 'undefined') {\n\t  root = window;\n\t} else if (typeof commonjsGlobal !== 'undefined') {\n\t  root = commonjsGlobal;\n\t} else if (typeof module !== 'undefined') {\n\t  root = module;\n\t} else {\n\t  root = Function('return this')();\n\t}\n\n\tvar result = (0, _ponyfill2['default'])(root);\n\texports['default'] = result;\n\t});\n\n\tvar require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n\tvar index = createCommonjsModule(function (module) {\n\tmodule.exports = require$$0;\n\t});\n\n\tvar $$observable = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n\tfunction fromESObservable(_observable) {\n\t  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n\t  return stream(function (emitter) {\n\t    var unsub = observable.subscribe({\n\t      error: function (error) {\n\t        emitter.error(error);\n\t        emitter.end();\n\t      },\n\t      next: function (value) {\n\t        emitter.emit(value);\n\t      },\n\t      complete: function () {\n\t        emitter.end();\n\t      }\n\t    });\n\n\t    if (unsub.unsubscribe) {\n\t      return function () {\n\t        unsub.unsubscribe();\n\t      };\n\t    } else {\n\t      return unsub;\n\t    }\n\t  }).setName('fromESObservable');\n\t}\n\n\tfunction ESObservable(observable) {\n\t  this._observable = observable.takeErrors(1);\n\t}\n\n\textend(ESObservable.prototype, {\n\t  subscribe: function (observerOrOnNext, onError, onComplete) {\n\t    var _this = this;\n\n\t    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;\n\n\t    var fn = function (event) {\n\t      if (event.type === END) {\n\t        closed = true;\n\t      }\n\n\t      if (event.type === VALUE && observer.next) {\n\t        observer.next(event.value);\n\t      } else if (event.type === ERROR && observer.error) {\n\t        observer.error(event.value);\n\t      } else if (event.type === END && observer.complete) {\n\t        observer.complete(event.value);\n\t      }\n\t    };\n\n\t    this._observable.onAny(fn);\n\t    var closed = false;\n\n\t    var subscription = {\n\t      unsubscribe: function () {\n\t        closed = true;\n\t        _this._observable.offAny(fn);\n\t      },\n\t      get closed() {\n\t        return closed;\n\t      }\n\t    };\n\t    return subscription;\n\t  }\n\t});\n\n\t// Need to assign directly b/c Symbols aren't enumerable.\n\tESObservable.prototype[$$observable] = function () {\n\t  return this;\n\t};\n\n\tfunction toESObservable() {\n\t  return new ESObservable(this);\n\t}\n\n\tfunction collect(source, keys, values) {\n\t  for (var prop in source) {\n\t    if (source.hasOwnProperty(prop)) {\n\t      keys.push(prop);\n\t      values.push(source[prop]);\n\t    }\n\t  }\n\t}\n\n\tfunction defaultErrorsCombinator(errors) {\n\t  var latestError = void 0;\n\t  for (var i = 0; i < errors.length; i++) {\n\t    if (errors[i] !== undefined) {\n\t      if (latestError === undefined || latestError.index < errors[i].index) {\n\t        latestError = errors[i];\n\t      }\n\t    }\n\t  }\n\t  return latestError.error;\n\t}\n\n\tfunction Combine(active, passive, combinator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\t  this._activeCount = active.length;\n\t  this._sources = concat(active, passive);\n\t  this._combinator = combinator;\n\t  this._aliveCount = 0;\n\t  this._latestValues = new Array(this._sources.length);\n\t  this._latestErrors = new Array(this._sources.length);\n\t  fillArray(this._latestValues, NOTHING);\n\t  this._emitAfterActivation = false;\n\t  this._endAfterActivation = false;\n\t  this._latestErrorIndex = 0;\n\n\t  this._$handlers = [];\n\n\t  var _loop = function (i) {\n\t    _this._$handlers.push(function (event) {\n\t      return _this._handleAny(i, event);\n\t    });\n\t  };\n\n\t  for (var i = 0; i < this._sources.length; i++) {\n\t    _loop(i);\n\t  }\n\t}\n\n\tinherit(Combine, Stream, {\n\n\t  _name: 'combine',\n\n\t  _onActivation: function () {\n\t    this._aliveCount = this._activeCount;\n\n\t    // we need to suscribe to _passive_ sources before _active_\n\t    // (see https://github.com/rpominov/kefir/issues/98)\n\t    for (var i = this._activeCount; i < this._sources.length; i++) {\n\t      this._sources[i].onAny(this._$handlers[i]);\n\t    }\n\t    for (var _i = 0; _i < this._activeCount; _i++) {\n\t      this._sources[_i].onAny(this._$handlers[_i]);\n\t    }\n\n\t    if (this._emitAfterActivation) {\n\t      this._emitAfterActivation = false;\n\t      this._emitIfFull();\n\t    }\n\t    if (this._endAfterActivation) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    var length = this._sources.length,\n\t        i = void 0;\n\t    for (i = 0; i < length; i++) {\n\t      this._sources[i].offAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _emitIfFull: function () {\n\t    var hasAllValues = true;\n\t    var hasErrors = false;\n\t    var length = this._latestValues.length;\n\t    var valuesCopy = new Array(length);\n\t    var errorsCopy = new Array(length);\n\n\t    for (var i = 0; i < length; i++) {\n\t      valuesCopy[i] = this._latestValues[i];\n\t      errorsCopy[i] = this._latestErrors[i];\n\n\t      if (valuesCopy[i] === NOTHING) {\n\t        hasAllValues = false;\n\t      }\n\n\t      if (errorsCopy[i] !== undefined) {\n\t        hasErrors = true;\n\t      }\n\t    }\n\n\t    if (hasAllValues) {\n\t      var combinator = this._combinator;\n\t      this._emitValue(combinator(valuesCopy));\n\t    }\n\t    if (hasErrors) {\n\t      this._emitError(defaultErrorsCombinator(errorsCopy));\n\t    }\n\t  },\n\t  _handleAny: function (i, event) {\n\n\t    if (event.type === VALUE || event.type === ERROR) {\n\n\t      if (event.type === VALUE) {\n\t        this._latestValues[i] = event.value;\n\t        this._latestErrors[i] = undefined;\n\t      }\n\t      if (event.type === ERROR) {\n\t        this._latestValues[i] = NOTHING;\n\t        this._latestErrors[i] = {\n\t          index: this._latestErrorIndex++,\n\t          error: event.value\n\t        };\n\t      }\n\n\t      if (i < this._activeCount) {\n\t        if (this._activating) {\n\t          this._emitAfterActivation = true;\n\t        } else {\n\t          this._emitIfFull();\n\t        }\n\t      }\n\t    } else {\n\t      // END\n\n\t      if (i < this._activeCount) {\n\t        this._aliveCount--;\n\t        if (this._aliveCount === 0) {\n\t          if (this._activating) {\n\t            this._endAfterActivation = true;\n\t          } else {\n\t            this._emitEnd();\n\t          }\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._sources = null;\n\t    this._latestValues = null;\n\t    this._latestErrors = null;\n\t    this._combinator = null;\n\t    this._$handlers = null;\n\t  }\n\t});\n\n\tfunction combineAsArray(active) {\n\t  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var combinator = arguments[2];\n\n\t  if (!Array.isArray(passive)) {\n\t    throw new Error('Combine can only combine active and passive collections of the same type.');\n\t  }\n\n\t  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {\n\t    return x;\n\t  };\n\t  return active.length === 0 ? never() : new Combine(active, passive, combinator);\n\t}\n\n\tfunction combineAsObject(active) {\n\t  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var combinator = arguments[2];\n\n\t  if (typeof passive !== 'object' || Array.isArray(passive)) {\n\t    throw new Error('Combine can only combine active and passive collections of the same type.');\n\t  }\n\n\t  var keys = [],\n\t      activeObservables = [],\n\t      passiveObservables = [];\n\n\t  collect(active, keys, activeObservables);\n\t  collect(passive, keys, passiveObservables);\n\n\t  var objectify = function (values) {\n\t    var event = {};\n\t    for (var i = values.length - 1; 0 <= i; i--) {\n\t      event[keys[i]] = values[i];\n\t    }\n\t    return combinator ? combinator(event) : event;\n\t  };\n\n\t  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n\t}\n\n\tfunction combine(active, passive, combinator) {\n\t  if (typeof passive === 'function') {\n\t    combinator = passive;\n\t    passive = undefined;\n\t  }\n\n\t  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n\t}\n\n\tvar Observable$1 = {\n\t  empty: function () {\n\t    return never();\n\t  },\n\n\n\t  // Monoid based on merge() seems more useful than one based on concat().\n\t  concat: function (a, b) {\n\t    return a.merge(b);\n\t  },\n\t  of: function (x) {\n\t    return constant(x);\n\t  },\n\t  map: function (fn, obs) {\n\t    return obs.map(fn);\n\t  },\n\t  bimap: function (fnErr, fnVal, obs) {\n\t    return obs.mapErrors(fnErr).map(fnVal);\n\t  },\n\n\n\t  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n\t  // different (not very useful) behavior. But spec requires that if method can be derived\n\t  // it must have the same behavior as hand-written method. We intentionally violate the spec\n\t  // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n\t  ap: function (obsFn, obsVal) {\n\t    return combine([obsFn, obsVal], function (fn, val) {\n\t      return fn(val);\n\t    });\n\t  },\n\t  chain: function (fn, obs) {\n\t    return obs.flatMap(fn);\n\t  }\n\t};\n\n\n\n\tvar staticLand = Object.freeze({\n\t  Observable: Observable$1\n\t});\n\n\tvar mixin = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    this._emitValue(fn(x));\n\t  }\n\t};\n\n\tvar S$7 = createStream('map', mixin);\n\tvar P$3 = createProperty('map', mixin);\n\n\tvar id = function (x) {\n\t  return x;\n\t};\n\n\tfunction map$1(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;\n\n\t  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n\t}\n\n\tvar mixin$1 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$8 = createStream('filter', mixin$1);\n\tvar P$4 = createProperty('filter', mixin$1);\n\n\tvar id$1 = function (x) {\n\t  return x;\n\t};\n\n\tfunction filter(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;\n\n\t  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n\t}\n\n\tvar mixin$2 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = n;\n\t    if (n <= 0) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._n--;\n\t    this._emitValue(x);\n\t    if (this._n === 0) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$9 = createStream('take', mixin$2);\n\tvar P$5 = createProperty('take', mixin$2);\n\n\tfunction take(obs, n) {\n\t  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n\t}\n\n\tvar mixin$3 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = n;\n\t    if (n <= 0) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleError: function (x) {\n\t    this._n--;\n\t    this._emitError(x);\n\t    if (this._n === 0) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$10 = createStream('takeErrors', mixin$3);\n\tvar P$6 = createProperty('takeErrors', mixin$3);\n\n\tfunction takeErrors(obs, n) {\n\t  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n\t}\n\n\tvar mixin$4 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$11 = createStream('takeWhile', mixin$4);\n\tvar P$7 = createProperty('takeWhile', mixin$4);\n\n\tvar id$2 = function (x) {\n\t  return x;\n\t};\n\n\tfunction takeWhile(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;\n\n\t  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n\t}\n\n\tvar mixin$5 = {\n\t  _init: function () {\n\t    this._lastValue = NOTHING;\n\t  },\n\t  _free: function () {\n\t    this._lastValue = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    this._lastValue = x;\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._lastValue !== NOTHING) {\n\t      this._emitValue(this._lastValue);\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$12 = createStream('last', mixin$5);\n\tvar P$8 = createProperty('last', mixin$5);\n\n\tfunction last(obs) {\n\t  return new (obs._ofSameType(S$12, P$8))(obs);\n\t}\n\n\tvar mixin$6 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = Math.max(0, n);\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._n === 0) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._n--;\n\t    }\n\t  }\n\t};\n\n\tvar S$13 = createStream('skip', mixin$6);\n\tvar P$9 = createProperty('skip', mixin$6);\n\n\tfunction skip(obs, n) {\n\t  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n\t}\n\n\tvar mixin$7 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._fn !== null && !fn(x)) {\n\t      this._fn = null;\n\t    }\n\t    if (this._fn === null) {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$14 = createStream('skipWhile', mixin$7);\n\tvar P$10 = createProperty('skipWhile', mixin$7);\n\n\tvar id$3 = function (x) {\n\t  return x;\n\t};\n\n\tfunction skipWhile(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;\n\n\t  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n\t}\n\n\tvar mixin$8 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t    this._prev = NOTHING;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._prev = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._prev === NOTHING || !fn(this._prev, x)) {\n\t      this._prev = x;\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$15 = createStream('skipDuplicates', mixin$8);\n\tvar P$11 = createProperty('skipDuplicates', mixin$8);\n\n\tvar eq = function (a, b) {\n\t  return a === b;\n\t};\n\n\tfunction skipDuplicates(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;\n\n\t  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n\t}\n\n\tvar mixin$9 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        seed = _ref.seed;\n\n\t    this._fn = fn;\n\t    this._prev = seed;\n\t  },\n\t  _free: function () {\n\t    this._prev = null;\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._prev !== NOTHING) {\n\t      var fn = this._fn;\n\t      this._emitValue(fn(this._prev, x));\n\t    }\n\t    this._prev = x;\n\t  }\n\t};\n\n\tvar S$16 = createStream('diff', mixin$9);\n\tvar P$12 = createProperty('diff', mixin$9);\n\n\tfunction defaultFn(a, b) {\n\t  return [a, b];\n\t}\n\n\tfunction diff(obs, fn) {\n\t  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n\t  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n\t}\n\n\tvar P$13 = createProperty('scan', {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        seed = _ref.seed;\n\n\t    this._fn = fn;\n\t    this._seed = seed;\n\t    if (seed !== NOTHING) {\n\t      this._emitValue(seed);\n\t    }\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._seed = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n\t      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n\t    } else {\n\t      this._emitValue(fn(this._currentEvent.value, x));\n\t    }\n\t  }\n\t});\n\n\tfunction scan(obs, fn) {\n\t  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n\t  return new P$13(obs, { fn: fn, seed: seed });\n\t}\n\n\tvar mixin$10 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    var xs = fn(x);\n\t    for (var i = 0; i < xs.length; i++) {\n\t      this._emitValue(xs[i]);\n\t    }\n\t  }\n\t};\n\n\tvar S$17 = createStream('flatten', mixin$10);\n\n\tvar id$4 = function (x) {\n\t  return x;\n\t};\n\n\tfunction flatten(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;\n\n\t  return new S$17(obs, { fn: fn });\n\t}\n\n\tvar END_MARKER = {};\n\n\tvar mixin$11 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._buff = [];\n\t    this._$shiftBuff = function () {\n\t      var value = _this._buff.shift();\n\t      if (value === END_MARKER) {\n\t        _this._emitEnd();\n\t      } else {\n\t        _this._emitValue(value);\n\t      }\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t    this._$shiftBuff = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._buff.push(x);\n\t      setTimeout(this._$shiftBuff, this._wait);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      this._buff.push(END_MARKER);\n\t      setTimeout(this._$shiftBuff, this._wait);\n\t    }\n\t  }\n\t};\n\n\tvar S$18 = createStream('delay', mixin$11);\n\tvar P$14 = createProperty('delay', mixin$11);\n\n\tfunction delay(obs, wait) {\n\t  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n\t}\n\n\tvar now = Date.now ? function () {\n\t  return Date.now();\n\t} : function () {\n\t  return new Date().getTime();\n\t};\n\n\tvar mixin$12 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        leading = _ref.leading,\n\t        trailing = _ref.trailing;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._leading = leading;\n\t    this._trailing = trailing;\n\t    this._trailingValue = null;\n\t    this._timeoutId = null;\n\t    this._endLater = false;\n\t    this._lastCallTime = 0;\n\t    this._$trailingCall = function () {\n\t      return _this._trailingCall();\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._trailingValue = null;\n\t    this._$trailingCall = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      var curTime = now();\n\t      if (this._lastCallTime === 0 && !this._leading) {\n\t        this._lastCallTime = curTime;\n\t      }\n\t      var remaining = this._wait - (curTime - this._lastCallTime);\n\t      if (remaining <= 0) {\n\t        this._cancelTrailing();\n\t        this._lastCallTime = curTime;\n\t        this._emitValue(x);\n\t      } else if (this._trailing) {\n\t        this._cancelTrailing();\n\t        this._trailingValue = x;\n\t        this._timeoutId = setTimeout(this._$trailingCall, remaining);\n\t      }\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      if (this._timeoutId) {\n\t        this._endLater = true;\n\t      } else {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _cancelTrailing: function () {\n\t    if (this._timeoutId !== null) {\n\t      clearTimeout(this._timeoutId);\n\t      this._timeoutId = null;\n\t    }\n\t  },\n\t  _trailingCall: function () {\n\t    this._emitValue(this._trailingValue);\n\t    this._timeoutId = null;\n\t    this._trailingValue = null;\n\t    this._lastCallTime = !this._leading ? 0 : now();\n\t    if (this._endLater) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$19 = createStream('throttle', mixin$12);\n\tvar P$15 = createProperty('throttle', mixin$12);\n\n\tfunction throttle(obs, wait) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$leading = _ref2.leading,\n\t      leading = _ref2$leading === undefined ? true : _ref2$leading,\n\t      _ref2$trailing = _ref2.trailing,\n\t      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n\t  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n\t}\n\n\tvar mixin$13 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        immediate = _ref.immediate;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._immediate = immediate;\n\t    this._lastAttempt = 0;\n\t    this._timeoutId = null;\n\t    this._laterValue = null;\n\t    this._endLater = false;\n\t    this._$later = function () {\n\t      return _this._later();\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._laterValue = null;\n\t    this._$later = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._lastAttempt = now();\n\t      if (this._immediate && !this._timeoutId) {\n\t        this._emitValue(x);\n\t      }\n\t      if (!this._timeoutId) {\n\t        this._timeoutId = setTimeout(this._$later, this._wait);\n\t      }\n\t      if (!this._immediate) {\n\t        this._laterValue = x;\n\t      }\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      if (this._timeoutId && !this._immediate) {\n\t        this._endLater = true;\n\t      } else {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _later: function () {\n\t    var last = now() - this._lastAttempt;\n\t    if (last < this._wait && last >= 0) {\n\t      this._timeoutId = setTimeout(this._$later, this._wait - last);\n\t    } else {\n\t      this._timeoutId = null;\n\t      if (!this._immediate) {\n\t        this._emitValue(this._laterValue);\n\t        this._laterValue = null;\n\t      }\n\t      if (this._endLater) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  }\n\t};\n\n\tvar S$20 = createStream('debounce', mixin$13);\n\tvar P$16 = createProperty('debounce', mixin$13);\n\n\tfunction debounce(obs, wait) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$immediate = _ref2.immediate,\n\t      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n\t  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n\t}\n\n\tvar mixin$14 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    this._emitError(fn(x));\n\t  }\n\t};\n\n\tvar S$21 = createStream('mapErrors', mixin$14);\n\tvar P$17 = createProperty('mapErrors', mixin$14);\n\n\tvar id$5 = function (x) {\n\t  return x;\n\t};\n\n\tfunction mapErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;\n\n\t  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n\t}\n\n\tvar mixin$15 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$22 = createStream('filterErrors', mixin$15);\n\tvar P$18 = createProperty('filterErrors', mixin$15);\n\n\tvar id$6 = function (x) {\n\t  return x;\n\t};\n\n\tfunction filterErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;\n\n\t  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n\t}\n\n\tvar mixin$16 = {\n\t  _handleValue: function () {}\n\t};\n\n\tvar S$23 = createStream('ignoreValues', mixin$16);\n\tvar P$19 = createProperty('ignoreValues', mixin$16);\n\n\tfunction ignoreValues(obs) {\n\t  return new (obs._ofSameType(S$23, P$19))(obs);\n\t}\n\n\tvar mixin$17 = {\n\t  _handleError: function () {}\n\t};\n\n\tvar S$24 = createStream('ignoreErrors', mixin$17);\n\tvar P$20 = createProperty('ignoreErrors', mixin$17);\n\n\tfunction ignoreErrors(obs) {\n\t  return new (obs._ofSameType(S$24, P$20))(obs);\n\t}\n\n\tvar mixin$18 = {\n\t  _handleEnd: function () {}\n\t};\n\n\tvar S$25 = createStream('ignoreEnd', mixin$18);\n\tvar P$21 = createProperty('ignoreEnd', mixin$18);\n\n\tfunction ignoreEnd(obs) {\n\t  return new (obs._ofSameType(S$25, P$21))(obs);\n\t}\n\n\tvar mixin$19 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleEnd: function () {\n\t    var fn = this._fn;\n\t    this._emitValue(fn());\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$26 = createStream('beforeEnd', mixin$19);\n\tvar P$22 = createProperty('beforeEnd', mixin$19);\n\n\tfunction beforeEnd(obs, fn) {\n\t  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n\t}\n\n\tvar mixin$20 = {\n\t  _init: function (_ref) {\n\t    var min = _ref.min,\n\t        max = _ref.max;\n\n\t    this._max = max;\n\t    this._min = min;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff = slide(this._buff, x, this._max);\n\t    if (this._buff.length >= this._min) {\n\t      this._emitValue(this._buff);\n\t    }\n\t  }\n\t};\n\n\tvar S$27 = createStream('slidingWindow', mixin$20);\n\tvar P$23 = createProperty('slidingWindow', mixin$20);\n\n\tfunction slidingWindow(obs, max) {\n\t  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n\t}\n\n\tvar mixin$21 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._fn = fn;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null && this._buff.length !== 0) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    var fn = this._fn;\n\t    if (!fn(x)) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$28 = createStream('bufferWhile', mixin$21);\n\tvar P$24 = createProperty('bufferWhile', mixin$21);\n\n\tvar id$7 = function (x) {\n\t  return x;\n\t};\n\n\tfunction bufferWhile(obs, fn) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n\t}\n\n\tvar mixin$22 = {\n\t  _init: function (_ref) {\n\t    var count = _ref.count,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._count = count;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null && this._buff.length !== 0) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._buff.length >= this._count) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$29 = createStream('bufferWithCount', mixin$22);\n\tvar P$25 = createProperty('bufferWithCount', mixin$22);\n\n\tfunction bufferWhile$1(obs, count) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n\t}\n\n\tvar mixin$23 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        count = _ref.count,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._wait = wait;\n\t    this._count = count;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._intervalId = null;\n\t    this._$onTick = function () {\n\t      return _this._flush();\n\t    };\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._$onTick = null;\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._buff.length >= this._count) {\n\t      clearInterval(this._intervalId);\n\t      this._flush();\n\t      this._intervalId = setInterval(this._$onTick, this._wait);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd && this._buff.length !== 0) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _onActivation: function () {\n\t    this._intervalId = setInterval(this._$onTick, this._wait);\n\t    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t  },\n\t  _onDeactivation: function () {\n\t    if (this._intervalId !== null) {\n\t      clearInterval(this._intervalId);\n\t      this._intervalId = null;\n\t    }\n\t    this._source.offAny(this._$handleAny); // copied from patterns/one-source\n\t  }\n\t};\n\n\tvar S$30 = createStream('bufferWithTimeOrCount', mixin$23);\n\tvar P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\n\tfunction bufferWithTimeOrCount(obs, wait, count) {\n\t  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n\t}\n\n\tfunction xformForObs(obs) {\n\t  return {\n\t    '@@transducer/step': function (res, input) {\n\t      obs._emitValue(input);\n\t      return null;\n\t    },\n\t    '@@transducer/result': function () {\n\t      obs._emitEnd();\n\t      return null;\n\t    }\n\t  };\n\t}\n\n\tvar mixin$24 = {\n\t  _init: function (_ref) {\n\t    var transducer = _ref.transducer;\n\n\t    this._xform = transducer(xformForObs(this));\n\t  },\n\t  _free: function () {\n\t    this._xform = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._xform['@@transducer/step'](null, x) !== null) {\n\t      this._xform['@@transducer/result'](null);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    this._xform['@@transducer/result'](null);\n\t  }\n\t};\n\n\tvar S$31 = createStream('transduce', mixin$24);\n\tvar P$27 = createProperty('transduce', mixin$24);\n\n\tfunction transduce(obs, transducer) {\n\t  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n\t}\n\n\tvar mixin$25 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._handler = fn;\n\t    this._emitter = emitter(this);\n\t  },\n\t  _free: function () {\n\t    this._handler = null;\n\t    this._emitter = null;\n\t  },\n\t  _handleAny: function (event) {\n\t    this._handler(this._emitter, event);\n\t  }\n\t};\n\n\tvar S$32 = createStream('withHandler', mixin$25);\n\tvar P$28 = createProperty('withHandler', mixin$25);\n\n\tfunction withHandler(obs, fn) {\n\t  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n\t}\n\n\tvar isArray = Array.isArray || function (xs) {\n\t  return Object.prototype.toString.call(xs) === '[object Array]';\n\t};\n\n\tfunction Zip(sources, combinator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\n\t  this._buffers = map(sources, function (source) {\n\t    return isArray(source) ? cloneArray(source) : [];\n\t  });\n\t  this._sources = map(sources, function (source) {\n\t    return isArray(source) ? never() : source;\n\t  });\n\n\t  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n\t    return x;\n\t  };\n\t  this._aliveCount = 0;\n\n\t  this._$handlers = [];\n\n\t  var _loop = function (i) {\n\t    _this._$handlers.push(function (event) {\n\t      return _this._handleAny(i, event);\n\t    });\n\t  };\n\n\t  for (var i = 0; i < this._sources.length; i++) {\n\t    _loop(i);\n\t  }\n\t}\n\n\tinherit(Zip, Stream, {\n\n\t  _name: 'zip',\n\n\t  _onActivation: function () {\n\n\t    // if all sources are arrays\n\t    while (this._isFull()) {\n\t      this._emit();\n\t    }\n\n\t    var length = this._sources.length;\n\t    this._aliveCount = length;\n\t    for (var i = 0; i < length && this._active; i++) {\n\t      this._sources[i].onAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    for (var i = 0; i < this._sources.length; i++) {\n\t      this._sources[i].offAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _emit: function () {\n\t    var values = new Array(this._buffers.length);\n\t    for (var i = 0; i < this._buffers.length; i++) {\n\t      values[i] = this._buffers[i].shift();\n\t    }\n\t    var combinator = this._combinator;\n\t    this._emitValue(combinator(values));\n\t  },\n\t  _isFull: function () {\n\t    for (var i = 0; i < this._buffers.length; i++) {\n\t      if (this._buffers[i].length === 0) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  },\n\t  _handleAny: function (i, event) {\n\t    if (event.type === VALUE) {\n\t      this._buffers[i].push(event.value);\n\t      if (this._isFull()) {\n\t        this._emit();\n\t      }\n\t    }\n\t    if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\t    if (event.type === END) {\n\t      this._aliveCount--;\n\t      if (this._aliveCount === 0) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._sources = null;\n\t    this._buffers = null;\n\t    this._combinator = null;\n\t    this._$handlers = null;\n\t  }\n\t});\n\n\tfunction zip(observables, combinator /* Function | falsey */) {\n\t  return observables.length === 0 ? never() : new Zip(observables, combinator);\n\t}\n\n\tvar id$8 = function (x) {\n\t  return x;\n\t};\n\n\tfunction AbstractPool() {\n\t  var _this = this;\n\n\t  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t      _ref$queueLim = _ref.queueLim,\n\t      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,\n\t      _ref$concurLim = _ref.concurLim,\n\t      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,\n\t      _ref$drop = _ref.drop,\n\t      drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n\t  Stream.call(this);\n\n\t  this._queueLim = queueLim < 0 ? -1 : queueLim;\n\t  this._concurLim = concurLim < 0 ? -1 : concurLim;\n\t  this._drop = drop;\n\t  this._queue = [];\n\t  this._curSources = [];\n\t  this._$handleSubAny = function (event) {\n\t    return _this._handleSubAny(event);\n\t  };\n\t  this._$endHandlers = [];\n\t  this._currentlyAdding = null;\n\n\t  if (this._concurLim === 0) {\n\t    this._emitEnd();\n\t  }\n\t}\n\n\tinherit(AbstractPool, Stream, {\n\n\t  _name: 'abstractPool',\n\n\t  _add: function (obj, toObs /* Function | falsey */) {\n\t    toObs = toObs || id$8;\n\t    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n\t      this._addToCur(toObs(obj));\n\t    } else {\n\t      if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n\t        this._addToQueue(toObs(obj));\n\t      } else if (this._drop === 'old') {\n\t        this._removeOldest();\n\t        this._add(obj, toObs);\n\t      }\n\t    }\n\t  },\n\t  _addAll: function (obss) {\n\t    var _this2 = this;\n\n\t    forEach(obss, function (obs) {\n\t      return _this2._add(obs);\n\t    });\n\t  },\n\t  _remove: function (obs) {\n\t    if (this._removeCur(obs) === -1) {\n\t      this._removeQueue(obs);\n\t    }\n\t  },\n\t  _addToQueue: function (obs) {\n\t    this._queue = concat(this._queue, [obs]);\n\t  },\n\t  _addToCur: function (obs) {\n\t    if (this._active) {\n\n\t      // HACK:\n\t      //\n\t      // We have two optimizations for cases when `obs` is ended. We don't want\n\t      // to add such observable to the list, but only want to emit events\n\t      // from it (if it has some).\n\t      //\n\t      // Instead of this hacks, we could just did following,\n\t      // but it would be 5-8 times slower:\n\t      //\n\t      //     this._curSources = concat(this._curSources, [obs]);\n\t      //     this._subscribe(obs);\n\t      //\n\n\t      // #1\n\t      // This one for cases when `obs` already ended\n\t      // e.g., Kefir.constant() or Kefir.never()\n\t      if (!obs._alive) {\n\t        if (obs._currentEvent) {\n\t          this._emit(obs._currentEvent.type, obs._currentEvent.value);\n\t        }\n\t        return;\n\t      }\n\n\t      // #2\n\t      // This one is for cases when `obs` going to end synchronously on\n\t      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n\t      this._currentlyAdding = obs;\n\t      obs.onAny(this._$handleSubAny);\n\t      this._currentlyAdding = null;\n\t      if (obs._alive) {\n\t        this._curSources = concat(this._curSources, [obs]);\n\t        if (this._active) {\n\t          this._subToEnd(obs);\n\t        }\n\t      }\n\t    } else {\n\t      this._curSources = concat(this._curSources, [obs]);\n\t    }\n\t  },\n\t  _subToEnd: function (obs) {\n\t    var _this3 = this;\n\n\t    var onEnd = function () {\n\t      return _this3._removeCur(obs);\n\t    };\n\t    this._$endHandlers.push({ obs: obs, handler: onEnd });\n\t    obs.onEnd(onEnd);\n\t  },\n\t  _subscribe: function (obs) {\n\t    obs.onAny(this._$handleSubAny);\n\n\t    // it can become inactive in responce of subscribing to `obs.onAny` above\n\t    if (this._active) {\n\t      this._subToEnd(obs);\n\t    }\n\t  },\n\t  _unsubscribe: function (obs) {\n\t    obs.offAny(this._$handleSubAny);\n\n\t    var onEndI = findByPred(this._$endHandlers, function (obj) {\n\t      return obj.obs === obs;\n\t    });\n\t    if (onEndI !== -1) {\n\t      obs.offEnd(this._$endHandlers[onEndI].handler);\n\t      this._$endHandlers.splice(onEndI, 1);\n\t    }\n\t  },\n\t  _handleSubAny: function (event) {\n\t    if (event.type === VALUE) {\n\t      this._emitValue(event.value);\n\t    } else if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\t  },\n\t  _removeQueue: function (obs) {\n\t    var index = find(this._queue, obs);\n\t    this._queue = remove(this._queue, index);\n\t    return index;\n\t  },\n\t  _removeCur: function (obs) {\n\t    if (this._active) {\n\t      this._unsubscribe(obs);\n\t    }\n\t    var index = find(this._curSources, obs);\n\t    this._curSources = remove(this._curSources, index);\n\t    if (index !== -1) {\n\t      if (this._queue.length !== 0) {\n\t        this._pullQueue();\n\t      } else if (this._curSources.length === 0) {\n\t        this._onEmpty();\n\t      }\n\t    }\n\t    return index;\n\t  },\n\t  _removeOldest: function () {\n\t    this._removeCur(this._curSources[0]);\n\t  },\n\t  _pullQueue: function () {\n\t    if (this._queue.length !== 0) {\n\t      this._queue = cloneArray(this._queue);\n\t      this._addToCur(this._queue.shift());\n\t    }\n\t  },\n\t  _onActivation: function () {\n\t    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n\t      this._subscribe(sources[i]);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n\t      this._unsubscribe(sources[i]);\n\t    }\n\t    if (this._currentlyAdding !== null) {\n\t      this._unsubscribe(this._currentlyAdding);\n\t    }\n\t  },\n\t  _isEmpty: function () {\n\t    return this._curSources.length === 0;\n\t  },\n\t  _onEmpty: function () {},\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._queue = null;\n\t    this._curSources = null;\n\t    this._$handleSubAny = null;\n\t    this._$endHandlers = null;\n\t  }\n\t});\n\n\tfunction Merge(sources) {\n\t  AbstractPool.call(this);\n\t  this._addAll(sources);\n\t  this._initialised = true;\n\t}\n\n\tinherit(Merge, AbstractPool, {\n\n\t  _name: 'merge',\n\n\t  _onEmpty: function () {\n\t    if (this._initialised) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t});\n\n\tfunction merge(observables) {\n\t  return observables.length === 0 ? never() : new Merge(observables);\n\t}\n\n\tfunction S$33(generator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\t  this._generator = generator;\n\t  this._source = null;\n\t  this._inLoop = false;\n\t  this._iteration = 0;\n\t  this._$handleAny = function (event) {\n\t    return _this._handleAny(event);\n\t  };\n\t}\n\n\tinherit(S$33, Stream, {\n\n\t  _name: 'repeat',\n\n\t  _handleAny: function (event) {\n\t    if (event.type === END) {\n\t      this._source = null;\n\t      this._getSource();\n\t    } else {\n\t      this._emit(event.type, event.value);\n\t    }\n\t  },\n\t  _getSource: function () {\n\t    if (!this._inLoop) {\n\t      this._inLoop = true;\n\t      var generator = this._generator;\n\t      while (this._source === null && this._alive && this._active) {\n\t        this._source = generator(this._iteration++);\n\t        if (this._source) {\n\t          this._source.onAny(this._$handleAny);\n\t        } else {\n\t          this._emitEnd();\n\t        }\n\t      }\n\t      this._inLoop = false;\n\t    }\n\t  },\n\t  _onActivation: function () {\n\t    if (this._source) {\n\t      this._source.onAny(this._$handleAny);\n\t    } else {\n\t      this._getSource();\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    if (this._source) {\n\t      this._source.offAny(this._$handleAny);\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._generator = null;\n\t    this._source = null;\n\t    this._$handleAny = null;\n\t  }\n\t});\n\n\tfunction repeat (generator) {\n\t  return new S$33(generator);\n\t}\n\n\tfunction concat$1(observables) {\n\t  return repeat(function (index) {\n\t    return observables.length > index ? observables[index] : false;\n\t  }).setName('concat');\n\t}\n\n\tfunction Pool() {\n\t  AbstractPool.call(this);\n\t}\n\n\tinherit(Pool, AbstractPool, {\n\n\t  _name: 'pool',\n\n\t  plug: function (obs) {\n\t    this._add(obs);\n\t    return this;\n\t  },\n\t  unplug: function (obs) {\n\t    this._remove(obs);\n\t    return this;\n\t  }\n\t});\n\n\tfunction FlatMap(source, fn, options) {\n\t  var _this = this;\n\n\t  AbstractPool.call(this, options);\n\t  this._source = source;\n\t  this._fn = fn;\n\t  this._mainEnded = false;\n\t  this._lastCurrent = null;\n\t  this._$handleMain = function (event) {\n\t    return _this._handleMain(event);\n\t  };\n\t}\n\n\tinherit(FlatMap, AbstractPool, {\n\t  _onActivation: function () {\n\t    AbstractPool.prototype._onActivation.call(this);\n\t    if (this._active) {\n\t      this._source.onAny(this._$handleMain);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    AbstractPool.prototype._onDeactivation.call(this);\n\t    this._source.offAny(this._$handleMain);\n\t    this._hadNoEvSinceDeact = true;\n\t  },\n\t  _handleMain: function (event) {\n\n\t    if (event.type === VALUE) {\n\t      // Is latest value before deactivation survived, and now is 'current' on this activation?\n\t      // We don't want to handle such values, to prevent to constantly add\n\t      // same observale on each activation/deactivation when our main source\n\t      // is a `Kefir.conatant()` for example.\n\t      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t      if (!sameCurr) {\n\t        this._add(event.value, this._fn);\n\t      }\n\t      this._lastCurrent = event.value;\n\t      this._hadNoEvSinceDeact = false;\n\t    }\n\n\t    if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\n\t    if (event.type === END) {\n\t      if (this._isEmpty()) {\n\t        this._emitEnd();\n\t      } else {\n\t        this._mainEnded = true;\n\t      }\n\t    }\n\t  },\n\t  _onEmpty: function () {\n\t    if (this._mainEnded) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _clear: function () {\n\t    AbstractPool.prototype._clear.call(this);\n\t    this._source = null;\n\t    this._lastCurrent = null;\n\t    this._$handleMain = null;\n\t  }\n\t});\n\n\tfunction FlatMapErrors(source, fn) {\n\t  FlatMap.call(this, source, fn);\n\t}\n\n\tinherit(FlatMapErrors, FlatMap, {\n\n\t  // Same as in FlatMap, only VALUE/ERROR flipped\n\t  _handleMain: function (event) {\n\n\t    if (event.type === ERROR) {\n\t      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t      if (!sameCurr) {\n\t        this._add(event.value, this._fn);\n\t      }\n\t      this._lastCurrent = event.value;\n\t      this._hadNoEvSinceDeact = false;\n\t    }\n\n\t    if (event.type === VALUE) {\n\t      this._emitValue(event.value);\n\t    }\n\n\t    if (event.type === END) {\n\t      if (this._isEmpty()) {\n\t        this._emitEnd();\n\t      } else {\n\t        this._mainEnded = true;\n\t      }\n\t    }\n\t  }\n\t});\n\n\tfunction createConstructor$1(BaseClass, name) {\n\t  return function AnonymousObservable(primary, secondary, options) {\n\t    var _this = this;\n\n\t    BaseClass.call(this);\n\t    this._primary = primary;\n\t    this._secondary = secondary;\n\t    this._name = primary._name + '.' + name;\n\t    this._lastSecondary = NOTHING;\n\t    this._$handleSecondaryAny = function (event) {\n\t      return _this._handleSecondaryAny(event);\n\t    };\n\t    this._$handlePrimaryAny = function (event) {\n\t      return _this._handlePrimaryAny(event);\n\t    };\n\t    this._init(options);\n\t  };\n\t}\n\n\tfunction createClassMethods$1(BaseClass) {\n\t  return {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _handlePrimaryValue: function (x) {\n\t      this._emitValue(x);\n\t    },\n\t    _handlePrimaryError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handlePrimaryEnd: function () {\n\t      this._emitEnd();\n\t    },\n\t    _handleSecondaryValue: function (x) {\n\t      this._lastSecondary = x;\n\t    },\n\t    _handleSecondaryError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handleSecondaryEnd: function () {},\n\t    _handlePrimaryAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handlePrimaryValue(event.value);\n\t        case ERROR:\n\t          return this._handlePrimaryError(event.value);\n\t        case END:\n\t          return this._handlePrimaryEnd(event.value);\n\t      }\n\t    },\n\t    _handleSecondaryAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handleSecondaryValue(event.value);\n\t        case ERROR:\n\t          return this._handleSecondaryError(event.value);\n\t        case END:\n\t          this._handleSecondaryEnd(event.value);\n\t          this._removeSecondary();\n\t      }\n\t    },\n\t    _removeSecondary: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.offAny(this._$handleSecondaryAny);\n\t        this._$handleSecondaryAny = null;\n\t        this._secondary = null;\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.onAny(this._$handleSecondaryAny);\n\t      }\n\t      if (this._active) {\n\t        this._primary.onAny(this._$handlePrimaryAny);\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.offAny(this._$handleSecondaryAny);\n\t      }\n\t      this._primary.offAny(this._$handlePrimaryAny);\n\t    },\n\t    _clear: function () {\n\t      BaseClass.prototype._clear.call(this);\n\t      this._primary = null;\n\t      this._secondary = null;\n\t      this._lastSecondary = null;\n\t      this._$handleSecondaryAny = null;\n\t      this._$handlePrimaryAny = null;\n\t      this._free();\n\t    }\n\t  };\n\t}\n\n\tfunction createStream$1(name, mixin) {\n\t  var S = createConstructor$1(Stream, name);\n\t  inherit(S, Stream, createClassMethods$1(Stream), mixin);\n\t  return S;\n\t}\n\n\tfunction createProperty$1(name, mixin) {\n\t  var P = createConstructor$1(Property, name);\n\t  inherit(P, Property, createClassMethods$1(Property), mixin);\n\t  return P;\n\t}\n\n\tvar mixin$26 = {\n\t  _handlePrimaryValue: function (x) {\n\t    if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$34 = createStream$1('filterBy', mixin$26);\n\tvar P$29 = createProperty$1('filterBy', mixin$26);\n\n\tfunction filterBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n\t}\n\n\tvar id2 = function (_, x) {\n\t  return x;\n\t};\n\n\tfunction sampledBy(passive, active, combinator) {\n\t  var _combinator = combinator ? function (a, b) {\n\t    return combinator(b, a);\n\t  } : id2;\n\t  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n\t}\n\n\tvar mixin$27 = {\n\t  _handlePrimaryValue: function (x) {\n\t    if (this._lastSecondary !== NOTHING) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (this._lastSecondary === NOTHING) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$35 = createStream$1('skipUntilBy', mixin$27);\n\tvar P$30 = createProperty$1('skipUntilBy', mixin$27);\n\n\tfunction skipUntilBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n\t}\n\n\tvar mixin$28 = {\n\t  _handleSecondaryValue: function () {\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$36 = createStream$1('takeUntilBy', mixin$28);\n\tvar P$31 = createProperty$1('takeUntilBy', mixin$28);\n\n\tfunction takeUntilBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n\t}\n\n\tvar mixin$29 = {\n\t  _init: function () {\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$flushOnEnd = _ref.flushOnEnd,\n\t        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n\t    this._buff = [];\n\t    this._flushOnEnd = flushOnEnd;\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handlePrimaryEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _onActivation: function () {\n\t    this._primary.onAny(this._$handlePrimaryAny);\n\t    if (this._alive && this._secondary !== null) {\n\t      this._secondary.onAny(this._$handleSecondaryAny);\n\t    }\n\t  },\n\t  _handlePrimaryValue: function (x) {\n\t    this._buff.push(x);\n\t  },\n\t  _handleSecondaryValue: function () {\n\t    this._flush();\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (!this._flushOnEnd) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$37 = createStream$1('bufferBy', mixin$29);\n\tvar P$32 = createProperty$1('bufferBy', mixin$29);\n\n\tfunction bufferBy(primary, secondary, options /* optional */) {\n\t  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n\t}\n\n\tvar mixin$30 = {\n\t  _init: function () {\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$flushOnEnd = _ref.flushOnEnd,\n\t        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,\n\t        _ref$flushOnChange = _ref.flushOnChange,\n\t        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n\t    this._buff = [];\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._flushOnChange = flushOnChange;\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handlePrimaryEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _handlePrimaryValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleSecondaryValue: function (x) {\n\t    if (this._flushOnChange && !x) {\n\t      this._flush();\n\t    }\n\n\t    // from default _handleSecondaryValue\n\t    this._lastSecondary = x;\n\t  }\n\t};\n\n\tvar S$38 = createStream$1('bufferWhileBy', mixin$30);\n\tvar P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\n\tfunction bufferWhileBy(primary, secondary, options /* optional */) {\n\t  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n\t}\n\n\tvar f = function () {\n\t  return false;\n\t};\n\tvar t = function () {\n\t  return true;\n\t};\n\n\tfunction awaiting(a, b) {\n\t  var result = merge([map$1(a, t), map$1(b, f)]);\n\t  result = skipDuplicates(result);\n\t  result = toProperty(result, f);\n\t  return result.setName(a, 'awaiting');\n\t}\n\n\tvar mixin$31 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    var result = fn(x);\n\t    if (result.convert) {\n\t      this._emitError(result.error);\n\t    } else {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$39 = createStream('valuesToErrors', mixin$31);\n\tvar P$34 = createProperty('valuesToErrors', mixin$31);\n\n\tvar defFn = function (x) {\n\t  return { convert: true, error: x };\n\t};\n\n\tfunction valuesToErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;\n\n\t  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n\t}\n\n\tvar mixin$32 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    var result = fn(x);\n\t    if (result.convert) {\n\t      this._emitValue(result.value);\n\t    } else {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$40 = createStream('errorsToValues', mixin$32);\n\tvar P$35 = createProperty('errorsToValues', mixin$32);\n\n\tvar defFn$1 = function (x) {\n\t  return { convert: true, value: x };\n\t};\n\n\tfunction errorsToValues(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;\n\n\t  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n\t}\n\n\tvar mixin$33 = {\n\t  _handleError: function (x) {\n\t    this._emitError(x);\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$41 = createStream('endOnError', mixin$33);\n\tvar P$36 = createProperty('endOnError', mixin$33);\n\n\tfunction endOnError(obs) {\n\t  return new (obs._ofSameType(S$41, P$36))(obs);\n\t}\n\n\tObservable.prototype.toProperty = function (fn) {\n\t  return toProperty(this, fn);\n\t};\n\n\tObservable.prototype.changes = function () {\n\t  return changes(this);\n\t};\n\n\tObservable.prototype.toPromise = function (Promise) {\n\t  return toPromise(this, Promise);\n\t};\n\n\tObservable.prototype.toESObservable = toESObservable;\n\tObservable.prototype[$$observable] = toESObservable;\n\n\tObservable.prototype.map = function (fn) {\n\t  return map$1(this, fn);\n\t};\n\n\tObservable.prototype.filter = function (fn) {\n\t  return filter(this, fn);\n\t};\n\n\tObservable.prototype.take = function (n) {\n\t  return take(this, n);\n\t};\n\n\tObservable.prototype.takeErrors = function (n) {\n\t  return takeErrors(this, n);\n\t};\n\n\tObservable.prototype.takeWhile = function (fn) {\n\t  return takeWhile(this, fn);\n\t};\n\n\tObservable.prototype.last = function () {\n\t  return last(this);\n\t};\n\n\tObservable.prototype.skip = function (n) {\n\t  return skip(this, n);\n\t};\n\n\tObservable.prototype.skipWhile = function (fn) {\n\t  return skipWhile(this, fn);\n\t};\n\n\tObservable.prototype.skipDuplicates = function (fn) {\n\t  return skipDuplicates(this, fn);\n\t};\n\n\tObservable.prototype.diff = function (fn, seed) {\n\t  return diff(this, fn, seed);\n\t};\n\n\tObservable.prototype.scan = function (fn, seed) {\n\t  return scan(this, fn, seed);\n\t};\n\n\tObservable.prototype.flatten = function (fn) {\n\t  return flatten(this, fn);\n\t};\n\n\tObservable.prototype.delay = function (wait) {\n\t  return delay(this, wait);\n\t};\n\n\tObservable.prototype.throttle = function (wait, options) {\n\t  return throttle(this, wait, options);\n\t};\n\n\tObservable.prototype.debounce = function (wait, options) {\n\t  return debounce(this, wait, options);\n\t};\n\n\tObservable.prototype.mapErrors = function (fn) {\n\t  return mapErrors(this, fn);\n\t};\n\n\tObservable.prototype.filterErrors = function (fn) {\n\t  return filterErrors(this, fn);\n\t};\n\n\tObservable.prototype.ignoreValues = function () {\n\t  return ignoreValues(this);\n\t};\n\n\tObservable.prototype.ignoreErrors = function () {\n\t  return ignoreErrors(this);\n\t};\n\n\tObservable.prototype.ignoreEnd = function () {\n\t  return ignoreEnd(this);\n\t};\n\n\tObservable.prototype.beforeEnd = function (fn) {\n\t  return beforeEnd(this, fn);\n\t};\n\n\tObservable.prototype.slidingWindow = function (max, min) {\n\t  return slidingWindow(this, max, min);\n\t};\n\n\tObservable.prototype.bufferWhile = function (fn, options) {\n\t  return bufferWhile(this, fn, options);\n\t};\n\n\tObservable.prototype.bufferWithCount = function (count, options) {\n\t  return bufferWhile$1(this, count, options);\n\t};\n\n\tObservable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n\t  return bufferWithTimeOrCount(this, wait, count, options);\n\t};\n\n\tObservable.prototype.transduce = function (transducer) {\n\t  return transduce(this, transducer);\n\t};\n\n\tObservable.prototype.withHandler = function (fn) {\n\t  return withHandler(this, fn);\n\t};\n\n\tObservable.prototype.combine = function (other, combinator) {\n\t  return combine([this, other], combinator);\n\t};\n\n\tObservable.prototype.zip = function (other, combinator) {\n\t  return zip([this, other], combinator);\n\t};\n\n\tObservable.prototype.merge = function (other) {\n\t  return merge([this, other]);\n\t};\n\n\tObservable.prototype.concat = function (other) {\n\t  return concat$1([this, other]);\n\t};\n\n\tvar pool = function () {\n\t  return new Pool();\n\t};\n\n\tObservable.prototype.flatMap = function (fn) {\n\t  return new FlatMap(this, fn).setName(this, 'flatMap');\n\t};\n\tObservable.prototype.flatMapLatest = function (fn) {\n\t  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n\t};\n\tObservable.prototype.flatMapFirst = function (fn) {\n\t  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n\t};\n\tObservable.prototype.flatMapConcat = function (fn) {\n\t  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n\t};\n\tObservable.prototype.flatMapConcurLimit = function (fn, limit) {\n\t  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n\t};\n\n\tObservable.prototype.flatMapErrors = function (fn) {\n\t  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n\t};\n\n\tObservable.prototype.filterBy = function (other) {\n\t  return filterBy(this, other);\n\t};\n\n\tObservable.prototype.sampledBy = function (other, combinator) {\n\t  return sampledBy(this, other, combinator);\n\t};\n\n\tObservable.prototype.skipUntilBy = function (other) {\n\t  return skipUntilBy(this, other);\n\t};\n\n\tObservable.prototype.takeUntilBy = function (other) {\n\t  return takeUntilBy(this, other);\n\t};\n\n\tObservable.prototype.bufferBy = function (other, options) {\n\t  return bufferBy(this, other, options);\n\t};\n\n\tObservable.prototype.bufferWhileBy = function (other, options) {\n\t  return bufferWhileBy(this, other, options);\n\t};\n\n\t// Deprecated\n\t// -----------------------------------------------------------------------------\n\n\tvar DEPRECATION_WARNINGS = true;\n\tfunction dissableDeprecationWarnings() {\n\t  DEPRECATION_WARNINGS = false;\n\t}\n\n\tfunction warn(msg) {\n\t  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {\n\t    var msg2 = '\\nHere is an Error object for you containing the call stack:';\n\t    console.warn(msg, msg2, new Error());\n\t  }\n\t}\n\n\tObservable.prototype.awaiting = function (other) {\n\t  warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');\n\t  return awaiting(this, other);\n\t};\n\n\tObservable.prototype.valuesToErrors = function (fn) {\n\t  warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');\n\t  return valuesToErrors(this, fn);\n\t};\n\n\tObservable.prototype.errorsToValues = function (fn) {\n\t  warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');\n\t  return errorsToValues(this, fn);\n\t};\n\n\tObservable.prototype.endOnError = function () {\n\t  warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');\n\t  return endOnError(this);\n\t};\n\n\t// Exports\n\t// --------------------------------------------------------------------------\n\n\tvar Kefir = { Observable: Observable, Stream: Stream, Property: Property, never: never, later: later, interval: interval, sequentially: sequentially,\n\t  fromPoll: fromPoll, withInterval: withInterval, fromCallback: fromCallback, fromNodeCallback: fromNodeCallback, fromEvents: fromEvents, stream: stream,\n\t  constant: constant, constantError: constantError, fromPromise: fromPromise, fromESObservable: fromESObservable, combine: combine, zip: zip, merge: merge,\n\t  concat: concat$1, Pool: Pool, pool: pool, repeat: repeat, staticLand: staticLand };\n\n\tKefir.Kefir = Kefir;\n\n\texports.dissableDeprecationWarnings = dissableDeprecationWarnings;\n\texports.Kefir = Kefir;\n\texports.Observable = Observable;\n\texports.Stream = Stream;\n\texports.Property = Property;\n\texports.never = never;\n\texports.later = later;\n\texports.interval = interval;\n\texports.sequentially = sequentially;\n\texports.fromPoll = fromPoll;\n\texports.withInterval = withInterval;\n\texports.fromCallback = fromCallback;\n\texports.fromNodeCallback = fromNodeCallback;\n\texports.fromEvents = fromEvents;\n\texports.stream = stream;\n\texports.constant = constant;\n\texports.constantError = constantError;\n\texports.fromPromise = fromPromise;\n\texports.fromESObservable = fromESObservable;\n\texports.combine = combine;\n\texports.zip = zip;\n\texports.merge = merge;\n\texports.concat = concat$1;\n\texports.Pool = Pool;\n\texports.pool = pool;\n\texports.repeat = repeat;\n\texports.staticLand = staticLand;\n\texports['default'] = Kefir;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// angular-bus.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f211e087aa70ce2b4feb","let Kefir = require('kefir');\nlet eventStream;\nlet publishEmitter;\nlet directory;\n\nlet SubscriptionDefinition = function(stream, callback, onError) {\n  this.stream = stream;\n  this.onUnsubscribe = null;\n  this.subscription = stream.observe({ value: function(ev) {callback(ev.data, ev);}, error: onError });\n  pegStream(stream);\n};\n\nSubscriptionDefinition.prototype.unsubscribe = function() {\n  if(typeof this.onUnsubscribe === 'function') {\n    this.onUnsubscribe();\n  }\n\n  this.subscription.unsubscribe();\n  unpegStream(this.stream);\n};\n\nfunction pegStream(stream) {\n  stream.subscriberCount = stream.subscriberCount ? stream.subscriberCount + 1 : 1;\n}\n\nfunction unpegStream(stream) {\n  if(!--stream.subscriberCount) {\n    delete directory[stream._source._channelName].topics[stream._binding];\n  }\n}\n\nfunction topicRegex(topic) {\n  let prevSegment;\n  let pattern = '^' + topic.split('.').map(function mapTopicBinding(segment) {\n      let res = '';\n      if(!!prevSegment) {\n        res = prevSegment !== '#' ? '\\\\.\\\\b' : '\\\\b';\n      }\n      if(segment === '#') {\n        res += '[\\\\s\\\\S]*';\n      } else if(segment === '*') {\n        res += '[^.]+';\n      } else {\n        res += segment;\n      }\n      prevSegment = segment;\n      return res;\n    }).join('') + '$';\n  return new RegExp(pattern);\n}\n\nfunction topicComparator(binding) {\n  if(binding.indexOf('#') === -1 && binding.indexOf('*') === -1) {\n    return (function(ev) { return ev.topic === binding; });\n  }\n  else {\n    let rgx = topicRegex(binding);\n    return (function(ev) { return rgx.test(ev.topic); });\n  }\n}\n\nfunction getChannel(name) {\n  if(!directory[name]) {\n    directory[name] = {\n      stream: eventStream.filter(function(ev) { return ev.channel === name; }),\n      topics: {}\n    };\n    directory[name].stream._channelName = name;\n  }\n  return directory[name];\n}\n\nfunction getTopicStream(channelName, binding) {\n  let channel = getChannel(channelName);\n  let cmp = topicComparator(binding);\n  let stream = channel.topics[binding] || (channel.topics[binding] = channel.stream.filter(function(ev) { return cmp(ev); }));\n  stream._binding = binding;\n  return stream;\n}\n\nfunction publish(event) {\n  event.timestamp = new Date().toISOString();\n  publishEmitter && publishEmitter.emit(event);\n}\n\nfunction subscribe(def) {\n  return new SubscriptionDefinition(getTopicStream(def.channel, def.topic), def.callback);\n}\n\nfunction addWireTap(callback) {\n  let subscription = eventStream.observe({ value: function(ev) { callback(ev.data, ev); } });\n  return function() { subscription.unsubscribe() };\n}\n\nfunction reset() {\n  directory = {};\n  publishEmitter && publishEmitter.end();\n  publishEmitter = null;\n  eventStream = Kefir.stream(function(emitter) {\n    publishEmitter = emitter;\n    return function() { publishEmitter = null; };\n  });\n}\n\nfunction when(defs, onSuccess, onError, options) {\n  let streams = [];\n  let _options = options || {};\n  defs.forEach(function(def) {\n    let stream = getTopicStream(def.channel, def.topic);\n    pegStream(stream);\n    streams.push(stream);\n  });\n  let aligned = Kefir.zip(streams);\n  let limited = _options.once ? aligned.take(1) : aligned;\n  let stripped = limited.map(function(data) { return data.map(function(el) { return el.data; }); });\n  let observer = stripped.observe({ value: function(data) { onSuccess.apply(this, data); }, error: onError, end: dispose });\n\n  function dispose() {\n    observer.unsubscribe();\n    streams.forEach(function(stream) {\n      unpegStream(stream);\n    });\n    streams = [];\n  }\n\n  return dispose;\n}\n\nreset();\n\nmodule.exports = {\n  publish: publish,\n  subscribe: subscribe,\n  addWireTap: addWireTap,\n  reset: reset,\n  when: when\n};\n\n\n\n// WEBPACK FOOTER //\n// ./pubsub.js","// Bind pubsub to Angular root scope as $event property\n(function() {\n  let pubsub = require('./pubsub');\n  angular.module('ngBus', []).config([\"$provide\", function($provide) {\n    $provide.decorator('$rootScope', [\"$delegate\", function($delegate) {\n        Object.defineProperty($delegate.constructor.prototype, '$event', {\n          get: function() {\n            let self = this;\n            return {\n              when: pubsub.when.bind(pubsub),\n              publish: pubsub.publish.bind(pubsub),\n              subscribe: function() {\n                let sub = pubsub.subscribe.apply(pubsub, arguments);\n                sub.onUnsubscribe = self.$on('$destroy', function() { sub.unsubscribe(); });\n                return sub;\n              },\n              addWireTap: pubsub.addWireTap.bind(pubsub),\n              reset: pubsub.reset\n            };\n          },\n          enumerable: false\n        });\n        return $delegate;\n      }]\n    );\n  }]);\n}());\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","/*! Kefir.js v3.7.1\n *  https://github.com/rpominov/kefir\n */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.Kefir = global.Kefir || {})));\n}(this, function (exports) { 'use strict';\n\n\tfunction createObj(proto) {\n\t  var F = function () {};\n\t  F.prototype = proto;\n\t  return new F();\n\t}\n\n\tfunction extend(target /*, mixin1, mixin2...*/) {\n\t  var length = arguments.length,\n\t      i = void 0,\n\t      prop = void 0;\n\t  for (i = 1; i < length; i++) {\n\t    for (prop in arguments[i]) {\n\t      target[prop] = arguments[i][prop];\n\t    }\n\t  }\n\t  return target;\n\t}\n\n\tfunction inherit(Child, Parent /*, mixin1, mixin2...*/) {\n\t  var length = arguments.length,\n\t      i = void 0;\n\t  Child.prototype = createObj(Parent.prototype);\n\t  Child.prototype.constructor = Child;\n\t  for (i = 2; i < length; i++) {\n\t    extend(Child.prototype, arguments[i]);\n\t  }\n\t  return Child;\n\t}\n\n\tvar NOTHING = ['<nothing>'];\n\tvar END = 'end';\n\tvar VALUE = 'value';\n\tvar ERROR = 'error';\n\tvar ANY = 'any';\n\n\tfunction concat(a, b) {\n\t  var result = void 0,\n\t      length = void 0,\n\t      i = void 0,\n\t      j = void 0;\n\t  if (a.length === 0) {\n\t    return b;\n\t  }\n\t  if (b.length === 0) {\n\t    return a;\n\t  }\n\t  j = 0;\n\t  result = new Array(a.length + b.length);\n\t  length = a.length;\n\t  for (i = 0; i < length; i++, j++) {\n\t    result[j] = a[i];\n\t  }\n\t  length = b.length;\n\t  for (i = 0; i < length; i++, j++) {\n\t    result[j] = b[i];\n\t  }\n\t  return result;\n\t}\n\n\tfunction find(arr, value) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    if (arr[i] === value) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction findByPred(arr, pred) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    if (pred(arr[i])) {\n\t      return i;\n\t    }\n\t  }\n\t  return -1;\n\t}\n\n\tfunction cloneArray(input) {\n\t  var length = input.length,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    result[i] = input[i];\n\t  }\n\t  return result;\n\t}\n\n\tfunction remove(input, index) {\n\t  var length = input.length,\n\t      result = void 0,\n\t      i = void 0,\n\t      j = void 0;\n\t  if (index >= 0 && index < length) {\n\t    if (length === 1) {\n\t      return [];\n\t    } else {\n\t      result = new Array(length - 1);\n\t      for (i = 0, j = 0; i < length; i++) {\n\t        if (i !== index) {\n\t          result[j] = input[i];\n\t          j++;\n\t        }\n\t      }\n\t      return result;\n\t    }\n\t  } else {\n\t    return input;\n\t  }\n\t}\n\n\tfunction map(input, fn) {\n\t  var length = input.length,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    result[i] = fn(input[i]);\n\t  }\n\t  return result;\n\t}\n\n\tfunction forEach(arr, fn) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    fn(arr[i]);\n\t  }\n\t}\n\n\tfunction fillArray(arr, value) {\n\t  var length = arr.length,\n\t      i = void 0;\n\t  for (i = 0; i < length; i++) {\n\t    arr[i] = value;\n\t  }\n\t}\n\n\tfunction contains(arr, value) {\n\t  return find(arr, value) !== -1;\n\t}\n\n\tfunction slide(cur, next, max) {\n\t  var length = Math.min(max, cur.length + 1),\n\t      offset = cur.length - length + 1,\n\t      result = new Array(length),\n\t      i = void 0;\n\t  for (i = offset; i < length; i++) {\n\t    result[i - offset] = cur[i];\n\t  }\n\t  result[length - 1] = next;\n\t  return result;\n\t}\n\n\tfunction callSubscriber(type, fn, event) {\n\t  if (type === ANY) {\n\t    fn(event);\n\t  } else if (type === event.type) {\n\t    if (type === VALUE || type === ERROR) {\n\t      fn(event.value);\n\t    } else {\n\t      fn();\n\t    }\n\t  }\n\t}\n\n\tfunction Dispatcher() {\n\t  this._items = [];\n\t  this._spies = [];\n\t  this._inLoop = 0;\n\t  this._removedItems = null;\n\t}\n\n\textend(Dispatcher.prototype, {\n\t  add: function (type, fn) {\n\t    this._items = concat(this._items, [{ type: type, fn: fn }]);\n\t    return this._items.length;\n\t  },\n\t  remove: function (type, fn) {\n\t    var index = findByPred(this._items, function (x) {\n\t      return x.type === type && x.fn === fn;\n\t    });\n\n\t    // if we're currently in a notification loop,\n\t    // remember this subscriber was removed\n\t    if (this._inLoop !== 0 && index !== -1) {\n\t      if (this._removedItems === null) {\n\t        this._removedItems = [];\n\t      }\n\t      this._removedItems.push(this._items[index]);\n\t    }\n\n\t    this._items = remove(this._items, index);\n\t    return this._items.length;\n\t  },\n\t  addSpy: function (fn) {\n\t    this._spies = concat(this._spies, [fn]);\n\t    return this._spies.length;\n\t  },\n\n\n\t  // Because spies are only ever a function that perform logging as\n\t  // their only side effect, we don't need the same complicated\n\t  // removal logic like in remove()\n\t  removeSpy: function (fn) {\n\t    this._spies = remove(this._spies, this._spies.indexOf(fn));\n\t    return this._spies.length;\n\t  },\n\t  dispatch: function (event) {\n\t    this._inLoop++;\n\t    for (var i = 0, spies = this._spies; this._spies !== null && i < spies.length; i++) {\n\t      spies[i](event);\n\t    }\n\n\t    for (var _i = 0, items = this._items; _i < items.length; _i++) {\n\n\t      // cleanup was called\n\t      if (this._items === null) {\n\t        break;\n\t      }\n\n\t      // this subscriber was removed\n\t      if (this._removedItems !== null && contains(this._removedItems, items[_i])) {\n\t        continue;\n\t      }\n\n\t      callSubscriber(items[_i].type, items[_i].fn, event);\n\t    }\n\t    this._inLoop--;\n\t    if (this._inLoop === 0) {\n\t      this._removedItems = null;\n\t    }\n\t  },\n\t  cleanup: function () {\n\t    this._items = null;\n\t    this._spies = null;\n\t  }\n\t});\n\n\tfunction Observable() {\n\t  this._dispatcher = new Dispatcher();\n\t  this._active = false;\n\t  this._alive = true;\n\t  this._activating = false;\n\t  this._logHandlers = null;\n\t  this._spyHandlers = null;\n\t}\n\n\textend(Observable.prototype, {\n\n\t  _name: 'observable',\n\n\t  _onActivation: function () {},\n\t  _onDeactivation: function () {},\n\t  _setActive: function (active) {\n\t    if (this._active !== active) {\n\t      this._active = active;\n\t      if (active) {\n\t        this._activating = true;\n\t        this._onActivation();\n\t        this._activating = false;\n\t      } else {\n\t        this._onDeactivation();\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    this._setActive(false);\n\t    this._dispatcher.cleanup();\n\t    this._dispatcher = null;\n\t    this._logHandlers = null;\n\t  },\n\t  _emit: function (type, x) {\n\t    switch (type) {\n\t      case VALUE:\n\t        return this._emitValue(x);\n\t      case ERROR:\n\t        return this._emitError(x);\n\t      case END:\n\t        return this._emitEnd();\n\t    }\n\t  },\n\t  _emitValue: function (value) {\n\t    if (this._alive) {\n\t      this._dispatcher.dispatch({ type: VALUE, value: value });\n\t    }\n\t  },\n\t  _emitError: function (value) {\n\t    if (this._alive) {\n\t      this._dispatcher.dispatch({ type: ERROR, value: value });\n\t    }\n\t  },\n\t  _emitEnd: function () {\n\t    if (this._alive) {\n\t      this._alive = false;\n\t      this._dispatcher.dispatch({ type: END });\n\t      this._clear();\n\t    }\n\t  },\n\t  _on: function (type, fn) {\n\t    if (this._alive) {\n\t      this._dispatcher.add(type, fn);\n\t      this._setActive(true);\n\t    } else {\n\t      callSubscriber(type, fn, { type: END });\n\t    }\n\t    return this;\n\t  },\n\t  _off: function (type, fn) {\n\t    if (this._alive) {\n\t      var count = this._dispatcher.remove(type, fn);\n\t      if (count === 0) {\n\t        this._setActive(false);\n\t      }\n\t    }\n\t    return this;\n\t  },\n\t  onValue: function (fn) {\n\t    return this._on(VALUE, fn);\n\t  },\n\t  onError: function (fn) {\n\t    return this._on(ERROR, fn);\n\t  },\n\t  onEnd: function (fn) {\n\t    return this._on(END, fn);\n\t  },\n\t  onAny: function (fn) {\n\t    return this._on(ANY, fn);\n\t  },\n\t  offValue: function (fn) {\n\t    return this._off(VALUE, fn);\n\t  },\n\t  offError: function (fn) {\n\t    return this._off(ERROR, fn);\n\t  },\n\t  offEnd: function (fn) {\n\t    return this._off(END, fn);\n\t  },\n\t  offAny: function (fn) {\n\t    return this._off(ANY, fn);\n\t  },\n\t  observe: function (observerOrOnValue, onError, onEnd) {\n\t    var _this = this;\n\t    var closed = false;\n\n\t    var observer = !observerOrOnValue || typeof observerOrOnValue === 'function' ? { value: observerOrOnValue, error: onError, end: onEnd } : observerOrOnValue;\n\n\t    var handler = function (event) {\n\t      if (event.type === END) {\n\t        closed = true;\n\t      }\n\t      if (event.type === VALUE && observer.value) {\n\t        observer.value(event.value);\n\t      } else if (event.type === ERROR && observer.error) {\n\t        observer.error(event.value);\n\t      } else if (event.type === END && observer.end) {\n\t        observer.end(event.value);\n\t      }\n\t    };\n\n\t    this.onAny(handler);\n\n\t    return {\n\t      unsubscribe: function () {\n\t        if (!closed) {\n\t          _this.offAny(handler);\n\t          closed = true;\n\t        }\n\t      },\n\n\t      get closed() {\n\t        return closed;\n\t      }\n\t    };\n\t  },\n\n\n\t  // A and B must be subclasses of Stream and Property (order doesn't matter)\n\t  _ofSameType: function (A, B) {\n\t    return A.prototype.getType() === this.getType() ? A : B;\n\t  },\n\t  setName: function (sourceObs /* optional */, selfName) {\n\t    this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n\t    return this;\n\t  },\n\t  log: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\n\t    var isCurrent = void 0;\n\t    var handler = function (event) {\n\t      var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n\t      if (event.type === END) {\n\t        console.log(name, type);\n\t      } else {\n\t        console.log(name, type, event.value);\n\t      }\n\t    };\n\n\t    if (this._alive) {\n\t      if (!this._logHandlers) {\n\t        this._logHandlers = [];\n\t      }\n\t      this._logHandlers.push({ name: name, handler: handler });\n\t    }\n\n\t    isCurrent = true;\n\t    this.onAny(handler);\n\t    isCurrent = false;\n\n\t    return this;\n\t  },\n\t  offLog: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\n\t    if (this._logHandlers) {\n\t      var handlerIndex = findByPred(this._logHandlers, function (obj) {\n\t        return obj.name === name;\n\t      });\n\t      if (handlerIndex !== -1) {\n\t        this.offAny(this._logHandlers[handlerIndex].handler);\n\t        this._logHandlers.splice(handlerIndex, 1);\n\t      }\n\t    }\n\n\t    return this;\n\t  },\n\t  spy: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\t    var handler = function (event) {\n\t      var type = '<' + event.type + '>';\n\t      if (event.type === END) {\n\t        console.log(name, type);\n\t      } else {\n\t        console.log(name, type, event.value);\n\t      }\n\t    };\n\t    if (this._alive) {\n\t      if (!this._spyHandlers) {\n\t        this._spyHandlers = [];\n\t      }\n\t      this._spyHandlers.push({ name: name, handler: handler });\n\t      this._dispatcher.addSpy(handler);\n\t    }\n\t    return this;\n\t  },\n\t  offSpy: function () {\n\t    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.toString();\n\n\t    if (this._spyHandlers) {\n\t      var handlerIndex = findByPred(this._spyHandlers, function (obj) {\n\t        return obj.name === name;\n\t      });\n\t      if (handlerIndex !== -1) {\n\t        this._dispatcher.removeSpy(this._spyHandlers[handlerIndex].handler);\n\t        this._spyHandlers.splice(handlerIndex, 1);\n\t      }\n\t    }\n\t    return this;\n\t  }\n\t});\n\n\t// extend() can't handle `toString` in IE8\n\tObservable.prototype.toString = function () {\n\t  return '[' + this._name + ']';\n\t};\n\n\tfunction Stream() {\n\t  Observable.call(this);\n\t}\n\n\tinherit(Stream, Observable, {\n\n\t  _name: 'stream',\n\n\t  getType: function () {\n\t    return 'stream';\n\t  }\n\t});\n\n\tfunction Property() {\n\t  Observable.call(this);\n\t  this._currentEvent = null;\n\t}\n\n\tinherit(Property, Observable, {\n\n\t  _name: 'property',\n\n\t  _emitValue: function (value) {\n\t    if (this._alive) {\n\t      this._currentEvent = { type: VALUE, value: value };\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: VALUE, value: value });\n\t      }\n\t    }\n\t  },\n\t  _emitError: function (value) {\n\t    if (this._alive) {\n\t      this._currentEvent = { type: ERROR, value: value };\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: ERROR, value: value });\n\t      }\n\t    }\n\t  },\n\t  _emitEnd: function () {\n\t    if (this._alive) {\n\t      this._alive = false;\n\t      if (!this._activating) {\n\t        this._dispatcher.dispatch({ type: END });\n\t      }\n\t      this._clear();\n\t    }\n\t  },\n\t  _on: function (type, fn) {\n\t    if (this._alive) {\n\t      this._dispatcher.add(type, fn);\n\t      this._setActive(true);\n\t    }\n\t    if (this._currentEvent !== null) {\n\t      callSubscriber(type, fn, this._currentEvent);\n\t    }\n\t    if (!this._alive) {\n\t      callSubscriber(type, fn, { type: END });\n\t    }\n\t    return this;\n\t  },\n\t  getType: function () {\n\t    return 'property';\n\t  }\n\t});\n\n\tvar neverS = new Stream();\n\tneverS._emitEnd();\n\tneverS._name = 'never';\n\n\tfunction never() {\n\t  return neverS;\n\t}\n\n\tfunction timeBased(mixin) {\n\n\t  function AnonymousStream(wait, options) {\n\t    var _this = this;\n\n\t    Stream.call(this);\n\t    this._wait = wait;\n\t    this._intervalId = null;\n\t    this._$onTick = function () {\n\t      return _this._onTick();\n\t    };\n\t    this._init(options);\n\t  }\n\n\t  inherit(AnonymousStream, Stream, {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _onTick: function () {},\n\t    _onActivation: function () {\n\t      this._intervalId = setInterval(this._$onTick, this._wait);\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._intervalId !== null) {\n\t        clearInterval(this._intervalId);\n\t        this._intervalId = null;\n\t      }\n\t    },\n\t    _clear: function () {\n\t      Stream.prototype._clear.call(this);\n\t      this._$onTick = null;\n\t      this._free();\n\t    }\n\t  }, mixin);\n\n\t  return AnonymousStream;\n\t}\n\n\tvar S = timeBased({\n\n\t  _name: 'later',\n\n\t  _init: function (_ref) {\n\t    var x = _ref.x;\n\n\t    this._x = x;\n\t  },\n\t  _free: function () {\n\t    this._x = null;\n\t  },\n\t  _onTick: function () {\n\t    this._emitValue(this._x);\n\t    this._emitEnd();\n\t  }\n\t});\n\n\tfunction later(wait, x) {\n\t  return new S(wait, { x: x });\n\t}\n\n\tvar S$1 = timeBased({\n\n\t  _name: 'interval',\n\n\t  _init: function (_ref) {\n\t    var x = _ref.x;\n\n\t    this._x = x;\n\t  },\n\t  _free: function () {\n\t    this._x = null;\n\t  },\n\t  _onTick: function () {\n\t    this._emitValue(this._x);\n\t  }\n\t});\n\n\tfunction interval(wait, x) {\n\t  return new S$1(wait, { x: x });\n\t}\n\n\tvar S$2 = timeBased({\n\n\t  _name: 'sequentially',\n\n\t  _init: function (_ref) {\n\t    var xs = _ref.xs;\n\n\t    this._xs = cloneArray(xs);\n\t  },\n\t  _free: function () {\n\t    this._xs = null;\n\t  },\n\t  _onTick: function () {\n\t    if (this._xs.length === 1) {\n\t      this._emitValue(this._xs[0]);\n\t      this._emitEnd();\n\t    } else {\n\t      this._emitValue(this._xs.shift());\n\t    }\n\t  }\n\t});\n\n\tfunction sequentially(wait, xs) {\n\t  return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n\t}\n\n\tvar S$3 = timeBased({\n\n\t  _name: 'fromPoll',\n\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _onTick: function () {\n\t    var fn = this._fn;\n\t    this._emitValue(fn());\n\t  }\n\t});\n\n\tfunction fromPoll(wait, fn) {\n\t  return new S$3(wait, { fn: fn });\n\t}\n\n\tfunction emitter(obs) {\n\n\t  function value(x) {\n\t    obs._emitValue(x);\n\t    return obs._active;\n\t  }\n\n\t  function error(x) {\n\t    obs._emitError(x);\n\t    return obs._active;\n\t  }\n\n\t  function end() {\n\t    obs._emitEnd();\n\t    return obs._active;\n\t  }\n\n\t  function event(e) {\n\t    obs._emit(e.type, e.value);\n\t    return obs._active;\n\t  }\n\n\t  return {\n\t    value: value,\n\t    error: error,\n\t    end: end,\n\t    event: event,\n\n\t    // legacy\n\t    emit: value,\n\t    emitEvent: event\n\t  };\n\t}\n\n\tvar S$4 = timeBased({\n\n\t  _name: 'withInterval',\n\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t    this._emitter = emitter(this);\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._emitter = null;\n\t  },\n\t  _onTick: function () {\n\t    var fn = this._fn;\n\t    fn(this._emitter);\n\t  }\n\t});\n\n\tfunction withInterval(wait, fn) {\n\t  return new S$4(wait, { fn: fn });\n\t}\n\n\tfunction S$5(fn) {\n\t  Stream.call(this);\n\t  this._fn = fn;\n\t  this._unsubscribe = null;\n\t}\n\n\tinherit(S$5, Stream, {\n\n\t  _name: 'stream',\n\n\t  _onActivation: function () {\n\t    var fn = this._fn;\n\t    var unsubscribe = fn(emitter(this));\n\t    this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\n\t    // fix https://github.com/rpominov/kefir/issues/35\n\t    if (!this._active) {\n\t      this._callUnsubscribe();\n\t    }\n\t  },\n\t  _callUnsubscribe: function () {\n\t    if (this._unsubscribe !== null) {\n\t      this._unsubscribe();\n\t      this._unsubscribe = null;\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    this._callUnsubscribe();\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._fn = null;\n\t  }\n\t});\n\n\tfunction stream(fn) {\n\t  return new S$5(fn);\n\t}\n\n\tfunction fromCallback(callbackConsumer) {\n\n\t  var called = false;\n\n\t  return stream(function (emitter) {\n\n\t    if (!called) {\n\t      callbackConsumer(function (x) {\n\t        emitter.emit(x);\n\t        emitter.end();\n\t      });\n\t      called = true;\n\t    }\n\t  }).setName('fromCallback');\n\t}\n\n\tfunction fromNodeCallback(callbackConsumer) {\n\n\t  var called = false;\n\n\t  return stream(function (emitter) {\n\n\t    if (!called) {\n\t      callbackConsumer(function (error, x) {\n\t        if (error) {\n\t          emitter.error(error);\n\t        } else {\n\t          emitter.emit(x);\n\t        }\n\t        emitter.end();\n\t      });\n\t      called = true;\n\t    }\n\t  }).setName('fromNodeCallback');\n\t}\n\n\tfunction spread(fn, length) {\n\t  switch (length) {\n\t    case 0:\n\t      return function () {\n\t        return fn();\n\t      };\n\t    case 1:\n\t      return function (a) {\n\t        return fn(a[0]);\n\t      };\n\t    case 2:\n\t      return function (a) {\n\t        return fn(a[0], a[1]);\n\t      };\n\t    case 3:\n\t      return function (a) {\n\t        return fn(a[0], a[1], a[2]);\n\t      };\n\t    case 4:\n\t      return function (a) {\n\t        return fn(a[0], a[1], a[2], a[3]);\n\t      };\n\t    default:\n\t      return function (a) {\n\t        return fn.apply(null, a);\n\t      };\n\t  }\n\t}\n\n\tfunction apply(fn, c, a) {\n\t  var aLength = a ? a.length : 0;\n\t  if (c == null) {\n\t    switch (aLength) {\n\t      case 0:\n\t        return fn();\n\t      case 1:\n\t        return fn(a[0]);\n\t      case 2:\n\t        return fn(a[0], a[1]);\n\t      case 3:\n\t        return fn(a[0], a[1], a[2]);\n\t      case 4:\n\t        return fn(a[0], a[1], a[2], a[3]);\n\t      default:\n\t        return fn.apply(null, a);\n\t    }\n\t  } else {\n\t    switch (aLength) {\n\t      case 0:\n\t        return fn.call(c);\n\t      default:\n\t        return fn.apply(c, a);\n\t    }\n\t  }\n\t}\n\n\tfunction fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n\t  return stream(function (emitter) {\n\n\t    var handler = transformer ? function () {\n\t      emitter.emit(apply(transformer, this, arguments));\n\t    } : function (x) {\n\t      emitter.emit(x);\n\t    };\n\n\t    sub(handler);\n\t    return function () {\n\t      return unsub(handler);\n\t    };\n\t  }).setName('fromSubUnsub');\n\t}\n\n\tvar pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\n\tfunction fromEvents(target, eventName, transformer) {\n\t  var sub = void 0,\n\t      unsub = void 0;\n\n\t  for (var i = 0; i < pairs.length; i++) {\n\t    if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n\t      sub = pairs[i][0];\n\t      unsub = pairs[i][1];\n\t      break;\n\t    }\n\t  }\n\n\t  if (sub === undefined) {\n\t    throw new Error('target don\\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n\t  }\n\n\t  return fromSubUnsub(function (handler) {\n\t    return target[sub](eventName, handler);\n\t  }, function (handler) {\n\t    return target[unsub](eventName, handler);\n\t  }, transformer).setName('fromEvents');\n\t}\n\n\t// HACK:\n\t//   We don't call parent Class constructor, but instead putting all necessary\n\t//   properties into prototype to simulate ended Property\n\t//   (see Propperty and Observable classes).\n\n\tfunction P(value) {\n\t  this._currentEvent = { type: 'value', value: value, current: true };\n\t}\n\n\tinherit(P, Property, {\n\t  _name: 'constant',\n\t  _active: false,\n\t  _activating: false,\n\t  _alive: false,\n\t  _dispatcher: null,\n\t  _logHandlers: null\n\t});\n\n\tfunction constant(x) {\n\t  return new P(x);\n\t}\n\n\t// HACK:\n\t//   We don't call parent Class constructor, but instead putting all necessary\n\t//   properties into prototype to simulate ended Property\n\t//   (see Propperty and Observable classes).\n\n\tfunction P$1(value) {\n\t  this._currentEvent = { type: 'error', value: value, current: true };\n\t}\n\n\tinherit(P$1, Property, {\n\t  _name: 'constantError',\n\t  _active: false,\n\t  _activating: false,\n\t  _alive: false,\n\t  _dispatcher: null,\n\t  _logHandlers: null\n\t});\n\n\tfunction constantError(x) {\n\t  return new P$1(x);\n\t}\n\n\tfunction createConstructor(BaseClass, name) {\n\t  return function AnonymousObservable(source, options) {\n\t    var _this = this;\n\n\t    BaseClass.call(this);\n\t    this._source = source;\n\t    this._name = source._name + '.' + name;\n\t    this._init(options);\n\t    this._$handleAny = function (event) {\n\t      return _this._handleAny(event);\n\t    };\n\t  };\n\t}\n\n\tfunction createClassMethods(BaseClass) {\n\t  return {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _handleValue: function (x) {\n\t      this._emitValue(x);\n\t    },\n\t    _handleError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handleEnd: function () {\n\t      this._emitEnd();\n\t    },\n\t    _handleAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handleValue(event.value);\n\t        case ERROR:\n\t          return this._handleError(event.value);\n\t        case END:\n\t          return this._handleEnd();\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      this._source.onAny(this._$handleAny);\n\t    },\n\t    _onDeactivation: function () {\n\t      this._source.offAny(this._$handleAny);\n\t    },\n\t    _clear: function () {\n\t      BaseClass.prototype._clear.call(this);\n\t      this._source = null;\n\t      this._$handleAny = null;\n\t      this._free();\n\t    }\n\t  };\n\t}\n\n\tfunction createStream(name, mixin) {\n\t  var S = createConstructor(Stream, name);\n\t  inherit(S, Stream, createClassMethods(Stream), mixin);\n\t  return S;\n\t}\n\n\tfunction createProperty(name, mixin) {\n\t  var P = createConstructor(Property, name);\n\t  inherit(P, Property, createClassMethods(Property), mixin);\n\t  return P;\n\t}\n\n\tvar P$2 = createProperty('toProperty', {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._getInitialCurrent = fn;\n\t  },\n\t  _onActivation: function () {\n\t    if (this._getInitialCurrent !== null) {\n\t      var getInitial = this._getInitialCurrent;\n\t      this._emitValue(getInitial());\n\t    }\n\t    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t  }\n\t});\n\n\tfunction toProperty(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t  if (fn !== null && typeof fn !== 'function') {\n\t    throw new Error('You should call toProperty() with a function or no arguments.');\n\t  }\n\t  return new P$2(obs, { fn: fn });\n\t}\n\n\tvar S$6 = createStream('changes', {\n\t  _handleValue: function (x) {\n\t    if (!this._activating) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleError: function (x) {\n\t    if (!this._activating) {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t});\n\n\tfunction changes(obs) {\n\t  return new S$6(obs);\n\t}\n\n\tfunction fromPromise(promise) {\n\n\t  var called = false;\n\n\t  var result = stream(function (emitter) {\n\t    if (!called) {\n\t      var onValue = function (x) {\n\t        emitter.emit(x);\n\t        emitter.end();\n\t      };\n\t      var onError = function (x) {\n\t        emitter.error(x);\n\t        emitter.end();\n\t      };\n\t      var _promise = promise.then(onValue, onError);\n\n\t      // prevent libraries like 'Q' or 'when' from swallowing exceptions\n\t      if (_promise && typeof _promise.done === 'function') {\n\t        _promise.done();\n\t      }\n\n\t      called = true;\n\t    }\n\t  });\n\n\t  return toProperty(result, null).setName('fromPromise');\n\t}\n\n\tfunction getGlodalPromise() {\n\t  if (typeof Promise === 'function') {\n\t    return Promise;\n\t  } else {\n\t    throw new Error('There isn\\'t default Promise, use shim or parameter');\n\t  }\n\t}\n\n\tfunction toPromise (obs) {\n\t  var Promise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlodalPromise();\n\n\t  var last = null;\n\t  return new Promise(function (resolve, reject) {\n\t    obs.onAny(function (event) {\n\t      if (event.type === END && last !== null) {\n\t        (last.type === VALUE ? resolve : reject)(last.value);\n\t        last = null;\n\t      } else {\n\t        last = event;\n\t      }\n\t    });\n\t  });\n\t}\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar ponyfill = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports['default'] = symbolObservablePonyfill;\n\tfunction symbolObservablePonyfill(root) {\n\t\tvar result;\n\t\tvar _Symbol = root.Symbol;\n\n\t\tif (typeof _Symbol === 'function') {\n\t\t\tif (_Symbol.observable) {\n\t\t\t\tresult = _Symbol.observable;\n\t\t\t} else {\n\t\t\t\tresult = _Symbol('observable');\n\t\t\t\t_Symbol.observable = result;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = '@@observable';\n\t\t}\n\n\t\treturn result;\n\t};\n\t});\n\n\tvar require$$0$1 = (ponyfill && typeof ponyfill === 'object' && 'default' in ponyfill ? ponyfill['default'] : ponyfill);\n\n\tvar index$1 = createCommonjsModule(function (module, exports) {\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _ponyfill = require$$0$1;\n\n\tvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\n\tfunction _interopRequireDefault(obj) {\n\t  return obj && obj.__esModule ? obj : { 'default': obj };\n\t}\n\n\tvar root; /* global window */\n\n\tif (typeof self !== 'undefined') {\n\t  root = self;\n\t} else if (typeof window !== 'undefined') {\n\t  root = window;\n\t} else if (typeof commonjsGlobal !== 'undefined') {\n\t  root = commonjsGlobal;\n\t} else if (typeof module !== 'undefined') {\n\t  root = module;\n\t} else {\n\t  root = Function('return this')();\n\t}\n\n\tvar result = (0, _ponyfill2['default'])(root);\n\texports['default'] = result;\n\t});\n\n\tvar require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);\n\n\tvar index = createCommonjsModule(function (module) {\n\tmodule.exports = require$$0;\n\t});\n\n\tvar $$observable = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n\tfunction fromESObservable(_observable) {\n\t  var observable = _observable[$$observable] ? _observable[$$observable]() : _observable;\n\t  return stream(function (emitter) {\n\t    var unsub = observable.subscribe({\n\t      error: function (error) {\n\t        emitter.error(error);\n\t        emitter.end();\n\t      },\n\t      next: function (value) {\n\t        emitter.emit(value);\n\t      },\n\t      complete: function () {\n\t        emitter.end();\n\t      }\n\t    });\n\n\t    if (unsub.unsubscribe) {\n\t      return function () {\n\t        unsub.unsubscribe();\n\t      };\n\t    } else {\n\t      return unsub;\n\t    }\n\t  }).setName('fromESObservable');\n\t}\n\n\tfunction ESObservable(observable) {\n\t  this._observable = observable.takeErrors(1);\n\t}\n\n\textend(ESObservable.prototype, {\n\t  subscribe: function (observerOrOnNext, onError, onComplete) {\n\t    var _this = this;\n\n\t    var observer = typeof observerOrOnNext === 'function' ? { next: observerOrOnNext, error: onError, complete: onComplete } : observerOrOnNext;\n\n\t    var fn = function (event) {\n\t      if (event.type === END) {\n\t        closed = true;\n\t      }\n\n\t      if (event.type === VALUE && observer.next) {\n\t        observer.next(event.value);\n\t      } else if (event.type === ERROR && observer.error) {\n\t        observer.error(event.value);\n\t      } else if (event.type === END && observer.complete) {\n\t        observer.complete(event.value);\n\t      }\n\t    };\n\n\t    this._observable.onAny(fn);\n\t    var closed = false;\n\n\t    var subscription = {\n\t      unsubscribe: function () {\n\t        closed = true;\n\t        _this._observable.offAny(fn);\n\t      },\n\t      get closed() {\n\t        return closed;\n\t      }\n\t    };\n\t    return subscription;\n\t  }\n\t});\n\n\t// Need to assign directly b/c Symbols aren't enumerable.\n\tESObservable.prototype[$$observable] = function () {\n\t  return this;\n\t};\n\n\tfunction toESObservable() {\n\t  return new ESObservable(this);\n\t}\n\n\tfunction collect(source, keys, values) {\n\t  for (var prop in source) {\n\t    if (source.hasOwnProperty(prop)) {\n\t      keys.push(prop);\n\t      values.push(source[prop]);\n\t    }\n\t  }\n\t}\n\n\tfunction defaultErrorsCombinator(errors) {\n\t  var latestError = void 0;\n\t  for (var i = 0; i < errors.length; i++) {\n\t    if (errors[i] !== undefined) {\n\t      if (latestError === undefined || latestError.index < errors[i].index) {\n\t        latestError = errors[i];\n\t      }\n\t    }\n\t  }\n\t  return latestError.error;\n\t}\n\n\tfunction Combine(active, passive, combinator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\t  this._activeCount = active.length;\n\t  this._sources = concat(active, passive);\n\t  this._combinator = combinator;\n\t  this._aliveCount = 0;\n\t  this._latestValues = new Array(this._sources.length);\n\t  this._latestErrors = new Array(this._sources.length);\n\t  fillArray(this._latestValues, NOTHING);\n\t  this._emitAfterActivation = false;\n\t  this._endAfterActivation = false;\n\t  this._latestErrorIndex = 0;\n\n\t  this._$handlers = [];\n\n\t  var _loop = function (i) {\n\t    _this._$handlers.push(function (event) {\n\t      return _this._handleAny(i, event);\n\t    });\n\t  };\n\n\t  for (var i = 0; i < this._sources.length; i++) {\n\t    _loop(i);\n\t  }\n\t}\n\n\tinherit(Combine, Stream, {\n\n\t  _name: 'combine',\n\n\t  _onActivation: function () {\n\t    this._aliveCount = this._activeCount;\n\n\t    // we need to suscribe to _passive_ sources before _active_\n\t    // (see https://github.com/rpominov/kefir/issues/98)\n\t    for (var i = this._activeCount; i < this._sources.length; i++) {\n\t      this._sources[i].onAny(this._$handlers[i]);\n\t    }\n\t    for (var _i = 0; _i < this._activeCount; _i++) {\n\t      this._sources[_i].onAny(this._$handlers[_i]);\n\t    }\n\n\t    if (this._emitAfterActivation) {\n\t      this._emitAfterActivation = false;\n\t      this._emitIfFull();\n\t    }\n\t    if (this._endAfterActivation) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    var length = this._sources.length,\n\t        i = void 0;\n\t    for (i = 0; i < length; i++) {\n\t      this._sources[i].offAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _emitIfFull: function () {\n\t    var hasAllValues = true;\n\t    var hasErrors = false;\n\t    var length = this._latestValues.length;\n\t    var valuesCopy = new Array(length);\n\t    var errorsCopy = new Array(length);\n\n\t    for (var i = 0; i < length; i++) {\n\t      valuesCopy[i] = this._latestValues[i];\n\t      errorsCopy[i] = this._latestErrors[i];\n\n\t      if (valuesCopy[i] === NOTHING) {\n\t        hasAllValues = false;\n\t      }\n\n\t      if (errorsCopy[i] !== undefined) {\n\t        hasErrors = true;\n\t      }\n\t    }\n\n\t    if (hasAllValues) {\n\t      var combinator = this._combinator;\n\t      this._emitValue(combinator(valuesCopy));\n\t    }\n\t    if (hasErrors) {\n\t      this._emitError(defaultErrorsCombinator(errorsCopy));\n\t    }\n\t  },\n\t  _handleAny: function (i, event) {\n\n\t    if (event.type === VALUE || event.type === ERROR) {\n\n\t      if (event.type === VALUE) {\n\t        this._latestValues[i] = event.value;\n\t        this._latestErrors[i] = undefined;\n\t      }\n\t      if (event.type === ERROR) {\n\t        this._latestValues[i] = NOTHING;\n\t        this._latestErrors[i] = {\n\t          index: this._latestErrorIndex++,\n\t          error: event.value\n\t        };\n\t      }\n\n\t      if (i < this._activeCount) {\n\t        if (this._activating) {\n\t          this._emitAfterActivation = true;\n\t        } else {\n\t          this._emitIfFull();\n\t        }\n\t      }\n\t    } else {\n\t      // END\n\n\t      if (i < this._activeCount) {\n\t        this._aliveCount--;\n\t        if (this._aliveCount === 0) {\n\t          if (this._activating) {\n\t            this._endAfterActivation = true;\n\t          } else {\n\t            this._emitEnd();\n\t          }\n\t        }\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._sources = null;\n\t    this._latestValues = null;\n\t    this._latestErrors = null;\n\t    this._combinator = null;\n\t    this._$handlers = null;\n\t  }\n\t});\n\n\tfunction combineAsArray(active) {\n\t  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var combinator = arguments[2];\n\n\t  if (!Array.isArray(passive)) {\n\t    throw new Error('Combine can only combine active and passive collections of the same type.');\n\t  }\n\n\t  combinator = combinator ? spread(combinator, active.length + passive.length) : function (x) {\n\t    return x;\n\t  };\n\t  return active.length === 0 ? never() : new Combine(active, passive, combinator);\n\t}\n\n\tfunction combineAsObject(active) {\n\t  var passive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var combinator = arguments[2];\n\n\t  if (typeof passive !== 'object' || Array.isArray(passive)) {\n\t    throw new Error('Combine can only combine active and passive collections of the same type.');\n\t  }\n\n\t  var keys = [],\n\t      activeObservables = [],\n\t      passiveObservables = [];\n\n\t  collect(active, keys, activeObservables);\n\t  collect(passive, keys, passiveObservables);\n\n\t  var objectify = function (values) {\n\t    var event = {};\n\t    for (var i = values.length - 1; 0 <= i; i--) {\n\t      event[keys[i]] = values[i];\n\t    }\n\t    return combinator ? combinator(event) : event;\n\t  };\n\n\t  return activeObservables.length === 0 ? never() : new Combine(activeObservables, passiveObservables, objectify);\n\t}\n\n\tfunction combine(active, passive, combinator) {\n\t  if (typeof passive === 'function') {\n\t    combinator = passive;\n\t    passive = undefined;\n\t  }\n\n\t  return Array.isArray(active) ? combineAsArray(active, passive, combinator) : combineAsObject(active, passive, combinator);\n\t}\n\n\tvar Observable$1 = {\n\t  empty: function () {\n\t    return never();\n\t  },\n\n\n\t  // Monoid based on merge() seems more useful than one based on concat().\n\t  concat: function (a, b) {\n\t    return a.merge(b);\n\t  },\n\t  of: function (x) {\n\t    return constant(x);\n\t  },\n\t  map: function (fn, obs) {\n\t    return obs.map(fn);\n\t  },\n\t  bimap: function (fnErr, fnVal, obs) {\n\t    return obs.mapErrors(fnErr).map(fnVal);\n\t  },\n\n\n\t  // This ap strictly speaking incompatible with chain. If we derive ap from chain we get\n\t  // different (not very useful) behavior. But spec requires that if method can be derived\n\t  // it must have the same behavior as hand-written method. We intentionally violate the spec\n\t  // in hope that it won't cause many troubles in practice. And in return we have more useful type.\n\t  ap: function (obsFn, obsVal) {\n\t    return combine([obsFn, obsVal], function (fn, val) {\n\t      return fn(val);\n\t    });\n\t  },\n\t  chain: function (fn, obs) {\n\t    return obs.flatMap(fn);\n\t  }\n\t};\n\n\n\n\tvar staticLand = Object.freeze({\n\t  Observable: Observable$1\n\t});\n\n\tvar mixin = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    this._emitValue(fn(x));\n\t  }\n\t};\n\n\tvar S$7 = createStream('map', mixin);\n\tvar P$3 = createProperty('map', mixin);\n\n\tvar id = function (x) {\n\t  return x;\n\t};\n\n\tfunction map$1(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id;\n\n\t  return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n\t}\n\n\tvar mixin$1 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$8 = createStream('filter', mixin$1);\n\tvar P$4 = createProperty('filter', mixin$1);\n\n\tvar id$1 = function (x) {\n\t  return x;\n\t};\n\n\tfunction filter(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$1;\n\n\t  return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n\t}\n\n\tvar mixin$2 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = n;\n\t    if (n <= 0) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._n--;\n\t    this._emitValue(x);\n\t    if (this._n === 0) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$9 = createStream('take', mixin$2);\n\tvar P$5 = createProperty('take', mixin$2);\n\n\tfunction take(obs, n) {\n\t  return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n\t}\n\n\tvar mixin$3 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = n;\n\t    if (n <= 0) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleError: function (x) {\n\t    this._n--;\n\t    this._emitError(x);\n\t    if (this._n === 0) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$10 = createStream('takeErrors', mixin$3);\n\tvar P$6 = createProperty('takeErrors', mixin$3);\n\n\tfunction takeErrors(obs, n) {\n\t  return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n\t}\n\n\tvar mixin$4 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$11 = createStream('takeWhile', mixin$4);\n\tvar P$7 = createProperty('takeWhile', mixin$4);\n\n\tvar id$2 = function (x) {\n\t  return x;\n\t};\n\n\tfunction takeWhile(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$2;\n\n\t  return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n\t}\n\n\tvar mixin$5 = {\n\t  _init: function () {\n\t    this._lastValue = NOTHING;\n\t  },\n\t  _free: function () {\n\t    this._lastValue = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    this._lastValue = x;\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._lastValue !== NOTHING) {\n\t      this._emitValue(this._lastValue);\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$12 = createStream('last', mixin$5);\n\tvar P$8 = createProperty('last', mixin$5);\n\n\tfunction last(obs) {\n\t  return new (obs._ofSameType(S$12, P$8))(obs);\n\t}\n\n\tvar mixin$6 = {\n\t  _init: function (_ref) {\n\t    var n = _ref.n;\n\n\t    this._n = Math.max(0, n);\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._n === 0) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._n--;\n\t    }\n\t  }\n\t};\n\n\tvar S$13 = createStream('skip', mixin$6);\n\tvar P$9 = createProperty('skip', mixin$6);\n\n\tfunction skip(obs, n) {\n\t  return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n\t}\n\n\tvar mixin$7 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._fn !== null && !fn(x)) {\n\t      this._fn = null;\n\t    }\n\t    if (this._fn === null) {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$14 = createStream('skipWhile', mixin$7);\n\tvar P$10 = createProperty('skipWhile', mixin$7);\n\n\tvar id$3 = function (x) {\n\t  return x;\n\t};\n\n\tfunction skipWhile(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$3;\n\n\t  return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n\t}\n\n\tvar mixin$8 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t    this._prev = NOTHING;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._prev = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._prev === NOTHING || !fn(this._prev, x)) {\n\t      this._prev = x;\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$15 = createStream('skipDuplicates', mixin$8);\n\tvar P$11 = createProperty('skipDuplicates', mixin$8);\n\n\tvar eq = function (a, b) {\n\t  return a === b;\n\t};\n\n\tfunction skipDuplicates(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eq;\n\n\t  return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n\t}\n\n\tvar mixin$9 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        seed = _ref.seed;\n\n\t    this._fn = fn;\n\t    this._prev = seed;\n\t  },\n\t  _free: function () {\n\t    this._prev = null;\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._prev !== NOTHING) {\n\t      var fn = this._fn;\n\t      this._emitValue(fn(this._prev, x));\n\t    }\n\t    this._prev = x;\n\t  }\n\t};\n\n\tvar S$16 = createStream('diff', mixin$9);\n\tvar P$12 = createProperty('diff', mixin$9);\n\n\tfunction defaultFn(a, b) {\n\t  return [a, b];\n\t}\n\n\tfunction diff(obs, fn) {\n\t  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n\t  return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n\t}\n\n\tvar P$13 = createProperty('scan', {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        seed = _ref.seed;\n\n\t    this._fn = fn;\n\t    this._seed = seed;\n\t    if (seed !== NOTHING) {\n\t      this._emitValue(seed);\n\t    }\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t    this._seed = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n\t      this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n\t    } else {\n\t      this._emitValue(fn(this._currentEvent.value, x));\n\t    }\n\t  }\n\t});\n\n\tfunction scan(obs, fn) {\n\t  var seed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NOTHING;\n\n\t  return new P$13(obs, { fn: fn, seed: seed });\n\t}\n\n\tvar mixin$10 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    var xs = fn(x);\n\t    for (var i = 0; i < xs.length; i++) {\n\t      this._emitValue(xs[i]);\n\t    }\n\t  }\n\t};\n\n\tvar S$17 = createStream('flatten', mixin$10);\n\n\tvar id$4 = function (x) {\n\t  return x;\n\t};\n\n\tfunction flatten(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$4;\n\n\t  return new S$17(obs, { fn: fn });\n\t}\n\n\tvar END_MARKER = {};\n\n\tvar mixin$11 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._buff = [];\n\t    this._$shiftBuff = function () {\n\t      var value = _this._buff.shift();\n\t      if (value === END_MARKER) {\n\t        _this._emitEnd();\n\t      } else {\n\t        _this._emitValue(value);\n\t      }\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t    this._$shiftBuff = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._buff.push(x);\n\t      setTimeout(this._$shiftBuff, this._wait);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      this._buff.push(END_MARKER);\n\t      setTimeout(this._$shiftBuff, this._wait);\n\t    }\n\t  }\n\t};\n\n\tvar S$18 = createStream('delay', mixin$11);\n\tvar P$14 = createProperty('delay', mixin$11);\n\n\tfunction delay(obs, wait) {\n\t  return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n\t}\n\n\tvar now = Date.now ? function () {\n\t  return Date.now();\n\t} : function () {\n\t  return new Date().getTime();\n\t};\n\n\tvar mixin$12 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        leading = _ref.leading,\n\t        trailing = _ref.trailing;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._leading = leading;\n\t    this._trailing = trailing;\n\t    this._trailingValue = null;\n\t    this._timeoutId = null;\n\t    this._endLater = false;\n\t    this._lastCallTime = 0;\n\t    this._$trailingCall = function () {\n\t      return _this._trailingCall();\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._trailingValue = null;\n\t    this._$trailingCall = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      var curTime = now();\n\t      if (this._lastCallTime === 0 && !this._leading) {\n\t        this._lastCallTime = curTime;\n\t      }\n\t      var remaining = this._wait - (curTime - this._lastCallTime);\n\t      if (remaining <= 0) {\n\t        this._cancelTrailing();\n\t        this._lastCallTime = curTime;\n\t        this._emitValue(x);\n\t      } else if (this._trailing) {\n\t        this._cancelTrailing();\n\t        this._trailingValue = x;\n\t        this._timeoutId = setTimeout(this._$trailingCall, remaining);\n\t      }\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      if (this._timeoutId) {\n\t        this._endLater = true;\n\t      } else {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _cancelTrailing: function () {\n\t    if (this._timeoutId !== null) {\n\t      clearTimeout(this._timeoutId);\n\t      this._timeoutId = null;\n\t    }\n\t  },\n\t  _trailingCall: function () {\n\t    this._emitValue(this._trailingValue);\n\t    this._timeoutId = null;\n\t    this._trailingValue = null;\n\t    this._lastCallTime = !this._leading ? 0 : now();\n\t    if (this._endLater) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$19 = createStream('throttle', mixin$12);\n\tvar P$15 = createProperty('throttle', mixin$12);\n\n\tfunction throttle(obs, wait) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$leading = _ref2.leading,\n\t      leading = _ref2$leading === undefined ? true : _ref2$leading,\n\t      _ref2$trailing = _ref2.trailing,\n\t      trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n\t  return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n\t}\n\n\tvar mixin$13 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        immediate = _ref.immediate;\n\n\t    this._wait = Math.max(0, wait);\n\t    this._immediate = immediate;\n\t    this._lastAttempt = 0;\n\t    this._timeoutId = null;\n\t    this._laterValue = null;\n\t    this._endLater = false;\n\t    this._$later = function () {\n\t      return _this._later();\n\t    };\n\t  },\n\t  _free: function () {\n\t    this._laterValue = null;\n\t    this._$later = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._activating) {\n\t      this._emitValue(x);\n\t    } else {\n\t      this._lastAttempt = now();\n\t      if (this._immediate && !this._timeoutId) {\n\t        this._emitValue(x);\n\t      }\n\t      if (!this._timeoutId) {\n\t        this._timeoutId = setTimeout(this._$later, this._wait);\n\t      }\n\t      if (!this._immediate) {\n\t        this._laterValue = x;\n\t      }\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._activating) {\n\t      this._emitEnd();\n\t    } else {\n\t      if (this._timeoutId && !this._immediate) {\n\t        this._endLater = true;\n\t      } else {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _later: function () {\n\t    var last = now() - this._lastAttempt;\n\t    if (last < this._wait && last >= 0) {\n\t      this._timeoutId = setTimeout(this._$later, this._wait - last);\n\t    } else {\n\t      this._timeoutId = null;\n\t      if (!this._immediate) {\n\t        this._emitValue(this._laterValue);\n\t        this._laterValue = null;\n\t      }\n\t      if (this._endLater) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  }\n\t};\n\n\tvar S$20 = createStream('debounce', mixin$13);\n\tvar P$16 = createProperty('debounce', mixin$13);\n\n\tfunction debounce(obs, wait) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$immediate = _ref2.immediate,\n\t      immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n\t  return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n\t}\n\n\tvar mixin$14 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    this._emitError(fn(x));\n\t  }\n\t};\n\n\tvar S$21 = createStream('mapErrors', mixin$14);\n\tvar P$17 = createProperty('mapErrors', mixin$14);\n\n\tvar id$5 = function (x) {\n\t  return x;\n\t};\n\n\tfunction mapErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$5;\n\n\t  return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n\t}\n\n\tvar mixin$15 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    if (fn(x)) {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$22 = createStream('filterErrors', mixin$15);\n\tvar P$18 = createProperty('filterErrors', mixin$15);\n\n\tvar id$6 = function (x) {\n\t  return x;\n\t};\n\n\tfunction filterErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : id$6;\n\n\t  return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n\t}\n\n\tvar mixin$16 = {\n\t  _handleValue: function () {}\n\t};\n\n\tvar S$23 = createStream('ignoreValues', mixin$16);\n\tvar P$19 = createProperty('ignoreValues', mixin$16);\n\n\tfunction ignoreValues(obs) {\n\t  return new (obs._ofSameType(S$23, P$19))(obs);\n\t}\n\n\tvar mixin$17 = {\n\t  _handleError: function () {}\n\t};\n\n\tvar S$24 = createStream('ignoreErrors', mixin$17);\n\tvar P$20 = createProperty('ignoreErrors', mixin$17);\n\n\tfunction ignoreErrors(obs) {\n\t  return new (obs._ofSameType(S$24, P$20))(obs);\n\t}\n\n\tvar mixin$18 = {\n\t  _handleEnd: function () {}\n\t};\n\n\tvar S$25 = createStream('ignoreEnd', mixin$18);\n\tvar P$21 = createProperty('ignoreEnd', mixin$18);\n\n\tfunction ignoreEnd(obs) {\n\t  return new (obs._ofSameType(S$25, P$21))(obs);\n\t}\n\n\tvar mixin$19 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleEnd: function () {\n\t    var fn = this._fn;\n\t    this._emitValue(fn());\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$26 = createStream('beforeEnd', mixin$19);\n\tvar P$22 = createProperty('beforeEnd', mixin$19);\n\n\tfunction beforeEnd(obs, fn) {\n\t  return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n\t}\n\n\tvar mixin$20 = {\n\t  _init: function (_ref) {\n\t    var min = _ref.min,\n\t        max = _ref.max;\n\n\t    this._max = max;\n\t    this._min = min;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff = slide(this._buff, x, this._max);\n\t    if (this._buff.length >= this._min) {\n\t      this._emitValue(this._buff);\n\t    }\n\t  }\n\t};\n\n\tvar S$27 = createStream('slidingWindow', mixin$20);\n\tvar P$23 = createProperty('slidingWindow', mixin$20);\n\n\tfunction slidingWindow(obs, max) {\n\t  var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n\t  return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n\t}\n\n\tvar mixin$21 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._fn = fn;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null && this._buff.length !== 0) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    var fn = this._fn;\n\t    if (!fn(x)) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$28 = createStream('bufferWhile', mixin$21);\n\tvar P$24 = createProperty('bufferWhile', mixin$21);\n\n\tvar id$7 = function (x) {\n\t  return x;\n\t};\n\n\tfunction bufferWhile(obs, fn) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n\t}\n\n\tvar mixin$22 = {\n\t  _init: function (_ref) {\n\t    var count = _ref.count,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._count = count;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null && this._buff.length !== 0) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._buff.length >= this._count) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$29 = createStream('bufferWithCount', mixin$22);\n\tvar P$25 = createProperty('bufferWithCount', mixin$22);\n\n\tfunction bufferWhile$1(obs, count) {\n\t  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n\t}\n\n\tvar mixin$23 = {\n\t  _init: function (_ref) {\n\t    var _this = this;\n\n\t    var wait = _ref.wait,\n\t        count = _ref.count,\n\t        flushOnEnd = _ref.flushOnEnd;\n\n\t    this._wait = wait;\n\t    this._count = count;\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._intervalId = null;\n\t    this._$onTick = function () {\n\t      return _this._flush();\n\t    };\n\t    this._buff = [];\n\t  },\n\t  _free: function () {\n\t    this._$onTick = null;\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handleValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._buff.length >= this._count) {\n\t      clearInterval(this._intervalId);\n\t      this._flush();\n\t      this._intervalId = setInterval(this._$onTick, this._wait);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    if (this._flushOnEnd && this._buff.length !== 0) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _onActivation: function () {\n\t    this._intervalId = setInterval(this._$onTick, this._wait);\n\t    this._source.onAny(this._$handleAny); // copied from patterns/one-source\n\t  },\n\t  _onDeactivation: function () {\n\t    if (this._intervalId !== null) {\n\t      clearInterval(this._intervalId);\n\t      this._intervalId = null;\n\t    }\n\t    this._source.offAny(this._$handleAny); // copied from patterns/one-source\n\t  }\n\t};\n\n\tvar S$30 = createStream('bufferWithTimeOrCount', mixin$23);\n\tvar P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\n\tfunction bufferWithTimeOrCount(obs, wait, count) {\n\t  var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n\t      _ref2$flushOnEnd = _ref2.flushOnEnd,\n\t      flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n\t  return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n\t}\n\n\tfunction xformForObs(obs) {\n\t  return {\n\t    '@@transducer/step': function (res, input) {\n\t      obs._emitValue(input);\n\t      return null;\n\t    },\n\t    '@@transducer/result': function () {\n\t      obs._emitEnd();\n\t      return null;\n\t    }\n\t  };\n\t}\n\n\tvar mixin$24 = {\n\t  _init: function (_ref) {\n\t    var transducer = _ref.transducer;\n\n\t    this._xform = transducer(xformForObs(this));\n\t  },\n\t  _free: function () {\n\t    this._xform = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    if (this._xform['@@transducer/step'](null, x) !== null) {\n\t      this._xform['@@transducer/result'](null);\n\t    }\n\t  },\n\t  _handleEnd: function () {\n\t    this._xform['@@transducer/result'](null);\n\t  }\n\t};\n\n\tvar S$31 = createStream('transduce', mixin$24);\n\tvar P$27 = createProperty('transduce', mixin$24);\n\n\tfunction transduce(obs, transducer) {\n\t  return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n\t}\n\n\tvar mixin$25 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._handler = fn;\n\t    this._emitter = emitter(this);\n\t  },\n\t  _free: function () {\n\t    this._handler = null;\n\t    this._emitter = null;\n\t  },\n\t  _handleAny: function (event) {\n\t    this._handler(this._emitter, event);\n\t  }\n\t};\n\n\tvar S$32 = createStream('withHandler', mixin$25);\n\tvar P$28 = createProperty('withHandler', mixin$25);\n\n\tfunction withHandler(obs, fn) {\n\t  return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n\t}\n\n\tvar isArray = Array.isArray || function (xs) {\n\t  return Object.prototype.toString.call(xs) === '[object Array]';\n\t};\n\n\tfunction Zip(sources, combinator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\n\t  this._buffers = map(sources, function (source) {\n\t    return isArray(source) ? cloneArray(source) : [];\n\t  });\n\t  this._sources = map(sources, function (source) {\n\t    return isArray(source) ? never() : source;\n\t  });\n\n\t  this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n\t    return x;\n\t  };\n\t  this._aliveCount = 0;\n\n\t  this._$handlers = [];\n\n\t  var _loop = function (i) {\n\t    _this._$handlers.push(function (event) {\n\t      return _this._handleAny(i, event);\n\t    });\n\t  };\n\n\t  for (var i = 0; i < this._sources.length; i++) {\n\t    _loop(i);\n\t  }\n\t}\n\n\tinherit(Zip, Stream, {\n\n\t  _name: 'zip',\n\n\t  _onActivation: function () {\n\n\t    // if all sources are arrays\n\t    while (this._isFull()) {\n\t      this._emit();\n\t    }\n\n\t    var length = this._sources.length;\n\t    this._aliveCount = length;\n\t    for (var i = 0; i < length && this._active; i++) {\n\t      this._sources[i].onAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    for (var i = 0; i < this._sources.length; i++) {\n\t      this._sources[i].offAny(this._$handlers[i]);\n\t    }\n\t  },\n\t  _emit: function () {\n\t    var values = new Array(this._buffers.length);\n\t    for (var i = 0; i < this._buffers.length; i++) {\n\t      values[i] = this._buffers[i].shift();\n\t    }\n\t    var combinator = this._combinator;\n\t    this._emitValue(combinator(values));\n\t  },\n\t  _isFull: function () {\n\t    for (var i = 0; i < this._buffers.length; i++) {\n\t      if (this._buffers[i].length === 0) {\n\t        return false;\n\t      }\n\t    }\n\t    return true;\n\t  },\n\t  _handleAny: function (i, event) {\n\t    if (event.type === VALUE) {\n\t      this._buffers[i].push(event.value);\n\t      if (this._isFull()) {\n\t        this._emit();\n\t      }\n\t    }\n\t    if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\t    if (event.type === END) {\n\t      this._aliveCount--;\n\t      if (this._aliveCount === 0) {\n\t        this._emitEnd();\n\t      }\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._sources = null;\n\t    this._buffers = null;\n\t    this._combinator = null;\n\t    this._$handlers = null;\n\t  }\n\t});\n\n\tfunction zip(observables, combinator /* Function | falsey */) {\n\t  return observables.length === 0 ? never() : new Zip(observables, combinator);\n\t}\n\n\tvar id$8 = function (x) {\n\t  return x;\n\t};\n\n\tfunction AbstractPool() {\n\t  var _this = this;\n\n\t  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t      _ref$queueLim = _ref.queueLim,\n\t      queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim,\n\t      _ref$concurLim = _ref.concurLim,\n\t      concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim,\n\t      _ref$drop = _ref.drop,\n\t      drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n\t  Stream.call(this);\n\n\t  this._queueLim = queueLim < 0 ? -1 : queueLim;\n\t  this._concurLim = concurLim < 0 ? -1 : concurLim;\n\t  this._drop = drop;\n\t  this._queue = [];\n\t  this._curSources = [];\n\t  this._$handleSubAny = function (event) {\n\t    return _this._handleSubAny(event);\n\t  };\n\t  this._$endHandlers = [];\n\t  this._currentlyAdding = null;\n\n\t  if (this._concurLim === 0) {\n\t    this._emitEnd();\n\t  }\n\t}\n\n\tinherit(AbstractPool, Stream, {\n\n\t  _name: 'abstractPool',\n\n\t  _add: function (obj, toObs /* Function | falsey */) {\n\t    toObs = toObs || id$8;\n\t    if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n\t      this._addToCur(toObs(obj));\n\t    } else {\n\t      if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n\t        this._addToQueue(toObs(obj));\n\t      } else if (this._drop === 'old') {\n\t        this._removeOldest();\n\t        this._add(obj, toObs);\n\t      }\n\t    }\n\t  },\n\t  _addAll: function (obss) {\n\t    var _this2 = this;\n\n\t    forEach(obss, function (obs) {\n\t      return _this2._add(obs);\n\t    });\n\t  },\n\t  _remove: function (obs) {\n\t    if (this._removeCur(obs) === -1) {\n\t      this._removeQueue(obs);\n\t    }\n\t  },\n\t  _addToQueue: function (obs) {\n\t    this._queue = concat(this._queue, [obs]);\n\t  },\n\t  _addToCur: function (obs) {\n\t    if (this._active) {\n\n\t      // HACK:\n\t      //\n\t      // We have two optimizations for cases when `obs` is ended. We don't want\n\t      // to add such observable to the list, but only want to emit events\n\t      // from it (if it has some).\n\t      //\n\t      // Instead of this hacks, we could just did following,\n\t      // but it would be 5-8 times slower:\n\t      //\n\t      //     this._curSources = concat(this._curSources, [obs]);\n\t      //     this._subscribe(obs);\n\t      //\n\n\t      // #1\n\t      // This one for cases when `obs` already ended\n\t      // e.g., Kefir.constant() or Kefir.never()\n\t      if (!obs._alive) {\n\t        if (obs._currentEvent) {\n\t          this._emit(obs._currentEvent.type, obs._currentEvent.value);\n\t        }\n\t        return;\n\t      }\n\n\t      // #2\n\t      // This one is for cases when `obs` going to end synchronously on\n\t      // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n\t      this._currentlyAdding = obs;\n\t      obs.onAny(this._$handleSubAny);\n\t      this._currentlyAdding = null;\n\t      if (obs._alive) {\n\t        this._curSources = concat(this._curSources, [obs]);\n\t        if (this._active) {\n\t          this._subToEnd(obs);\n\t        }\n\t      }\n\t    } else {\n\t      this._curSources = concat(this._curSources, [obs]);\n\t    }\n\t  },\n\t  _subToEnd: function (obs) {\n\t    var _this3 = this;\n\n\t    var onEnd = function () {\n\t      return _this3._removeCur(obs);\n\t    };\n\t    this._$endHandlers.push({ obs: obs, handler: onEnd });\n\t    obs.onEnd(onEnd);\n\t  },\n\t  _subscribe: function (obs) {\n\t    obs.onAny(this._$handleSubAny);\n\n\t    // it can become inactive in responce of subscribing to `obs.onAny` above\n\t    if (this._active) {\n\t      this._subToEnd(obs);\n\t    }\n\t  },\n\t  _unsubscribe: function (obs) {\n\t    obs.offAny(this._$handleSubAny);\n\n\t    var onEndI = findByPred(this._$endHandlers, function (obj) {\n\t      return obj.obs === obs;\n\t    });\n\t    if (onEndI !== -1) {\n\t      obs.offEnd(this._$endHandlers[onEndI].handler);\n\t      this._$endHandlers.splice(onEndI, 1);\n\t    }\n\t  },\n\t  _handleSubAny: function (event) {\n\t    if (event.type === VALUE) {\n\t      this._emitValue(event.value);\n\t    } else if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\t  },\n\t  _removeQueue: function (obs) {\n\t    var index = find(this._queue, obs);\n\t    this._queue = remove(this._queue, index);\n\t    return index;\n\t  },\n\t  _removeCur: function (obs) {\n\t    if (this._active) {\n\t      this._unsubscribe(obs);\n\t    }\n\t    var index = find(this._curSources, obs);\n\t    this._curSources = remove(this._curSources, index);\n\t    if (index !== -1) {\n\t      if (this._queue.length !== 0) {\n\t        this._pullQueue();\n\t      } else if (this._curSources.length === 0) {\n\t        this._onEmpty();\n\t      }\n\t    }\n\t    return index;\n\t  },\n\t  _removeOldest: function () {\n\t    this._removeCur(this._curSources[0]);\n\t  },\n\t  _pullQueue: function () {\n\t    if (this._queue.length !== 0) {\n\t      this._queue = cloneArray(this._queue);\n\t      this._addToCur(this._queue.shift());\n\t    }\n\t  },\n\t  _onActivation: function () {\n\t    for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n\t      this._subscribe(sources[i]);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n\t      this._unsubscribe(sources[i]);\n\t    }\n\t    if (this._currentlyAdding !== null) {\n\t      this._unsubscribe(this._currentlyAdding);\n\t    }\n\t  },\n\t  _isEmpty: function () {\n\t    return this._curSources.length === 0;\n\t  },\n\t  _onEmpty: function () {},\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._queue = null;\n\t    this._curSources = null;\n\t    this._$handleSubAny = null;\n\t    this._$endHandlers = null;\n\t  }\n\t});\n\n\tfunction Merge(sources) {\n\t  AbstractPool.call(this);\n\t  this._addAll(sources);\n\t  this._initialised = true;\n\t}\n\n\tinherit(Merge, AbstractPool, {\n\n\t  _name: 'merge',\n\n\t  _onEmpty: function () {\n\t    if (this._initialised) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t});\n\n\tfunction merge(observables) {\n\t  return observables.length === 0 ? never() : new Merge(observables);\n\t}\n\n\tfunction S$33(generator) {\n\t  var _this = this;\n\n\t  Stream.call(this);\n\t  this._generator = generator;\n\t  this._source = null;\n\t  this._inLoop = false;\n\t  this._iteration = 0;\n\t  this._$handleAny = function (event) {\n\t    return _this._handleAny(event);\n\t  };\n\t}\n\n\tinherit(S$33, Stream, {\n\n\t  _name: 'repeat',\n\n\t  _handleAny: function (event) {\n\t    if (event.type === END) {\n\t      this._source = null;\n\t      this._getSource();\n\t    } else {\n\t      this._emit(event.type, event.value);\n\t    }\n\t  },\n\t  _getSource: function () {\n\t    if (!this._inLoop) {\n\t      this._inLoop = true;\n\t      var generator = this._generator;\n\t      while (this._source === null && this._alive && this._active) {\n\t        this._source = generator(this._iteration++);\n\t        if (this._source) {\n\t          this._source.onAny(this._$handleAny);\n\t        } else {\n\t          this._emitEnd();\n\t        }\n\t      }\n\t      this._inLoop = false;\n\t    }\n\t  },\n\t  _onActivation: function () {\n\t    if (this._source) {\n\t      this._source.onAny(this._$handleAny);\n\t    } else {\n\t      this._getSource();\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    if (this._source) {\n\t      this._source.offAny(this._$handleAny);\n\t    }\n\t  },\n\t  _clear: function () {\n\t    Stream.prototype._clear.call(this);\n\t    this._generator = null;\n\t    this._source = null;\n\t    this._$handleAny = null;\n\t  }\n\t});\n\n\tfunction repeat (generator) {\n\t  return new S$33(generator);\n\t}\n\n\tfunction concat$1(observables) {\n\t  return repeat(function (index) {\n\t    return observables.length > index ? observables[index] : false;\n\t  }).setName('concat');\n\t}\n\n\tfunction Pool() {\n\t  AbstractPool.call(this);\n\t}\n\n\tinherit(Pool, AbstractPool, {\n\n\t  _name: 'pool',\n\n\t  plug: function (obs) {\n\t    this._add(obs);\n\t    return this;\n\t  },\n\t  unplug: function (obs) {\n\t    this._remove(obs);\n\t    return this;\n\t  }\n\t});\n\n\tfunction FlatMap(source, fn, options) {\n\t  var _this = this;\n\n\t  AbstractPool.call(this, options);\n\t  this._source = source;\n\t  this._fn = fn;\n\t  this._mainEnded = false;\n\t  this._lastCurrent = null;\n\t  this._$handleMain = function (event) {\n\t    return _this._handleMain(event);\n\t  };\n\t}\n\n\tinherit(FlatMap, AbstractPool, {\n\t  _onActivation: function () {\n\t    AbstractPool.prototype._onActivation.call(this);\n\t    if (this._active) {\n\t      this._source.onAny(this._$handleMain);\n\t    }\n\t  },\n\t  _onDeactivation: function () {\n\t    AbstractPool.prototype._onDeactivation.call(this);\n\t    this._source.offAny(this._$handleMain);\n\t    this._hadNoEvSinceDeact = true;\n\t  },\n\t  _handleMain: function (event) {\n\n\t    if (event.type === VALUE) {\n\t      // Is latest value before deactivation survived, and now is 'current' on this activation?\n\t      // We don't want to handle such values, to prevent to constantly add\n\t      // same observale on each activation/deactivation when our main source\n\t      // is a `Kefir.conatant()` for example.\n\t      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t      if (!sameCurr) {\n\t        this._add(event.value, this._fn);\n\t      }\n\t      this._lastCurrent = event.value;\n\t      this._hadNoEvSinceDeact = false;\n\t    }\n\n\t    if (event.type === ERROR) {\n\t      this._emitError(event.value);\n\t    }\n\n\t    if (event.type === END) {\n\t      if (this._isEmpty()) {\n\t        this._emitEnd();\n\t      } else {\n\t        this._mainEnded = true;\n\t      }\n\t    }\n\t  },\n\t  _onEmpty: function () {\n\t    if (this._mainEnded) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _clear: function () {\n\t    AbstractPool.prototype._clear.call(this);\n\t    this._source = null;\n\t    this._lastCurrent = null;\n\t    this._$handleMain = null;\n\t  }\n\t});\n\n\tfunction FlatMapErrors(source, fn) {\n\t  FlatMap.call(this, source, fn);\n\t}\n\n\tinherit(FlatMapErrors, FlatMap, {\n\n\t  // Same as in FlatMap, only VALUE/ERROR flipped\n\t  _handleMain: function (event) {\n\n\t    if (event.type === ERROR) {\n\t      var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n\t      if (!sameCurr) {\n\t        this._add(event.value, this._fn);\n\t      }\n\t      this._lastCurrent = event.value;\n\t      this._hadNoEvSinceDeact = false;\n\t    }\n\n\t    if (event.type === VALUE) {\n\t      this._emitValue(event.value);\n\t    }\n\n\t    if (event.type === END) {\n\t      if (this._isEmpty()) {\n\t        this._emitEnd();\n\t      } else {\n\t        this._mainEnded = true;\n\t      }\n\t    }\n\t  }\n\t});\n\n\tfunction createConstructor$1(BaseClass, name) {\n\t  return function AnonymousObservable(primary, secondary, options) {\n\t    var _this = this;\n\n\t    BaseClass.call(this);\n\t    this._primary = primary;\n\t    this._secondary = secondary;\n\t    this._name = primary._name + '.' + name;\n\t    this._lastSecondary = NOTHING;\n\t    this._$handleSecondaryAny = function (event) {\n\t      return _this._handleSecondaryAny(event);\n\t    };\n\t    this._$handlePrimaryAny = function (event) {\n\t      return _this._handlePrimaryAny(event);\n\t    };\n\t    this._init(options);\n\t  };\n\t}\n\n\tfunction createClassMethods$1(BaseClass) {\n\t  return {\n\t    _init: function () {},\n\t    _free: function () {},\n\t    _handlePrimaryValue: function (x) {\n\t      this._emitValue(x);\n\t    },\n\t    _handlePrimaryError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handlePrimaryEnd: function () {\n\t      this._emitEnd();\n\t    },\n\t    _handleSecondaryValue: function (x) {\n\t      this._lastSecondary = x;\n\t    },\n\t    _handleSecondaryError: function (x) {\n\t      this._emitError(x);\n\t    },\n\t    _handleSecondaryEnd: function () {},\n\t    _handlePrimaryAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handlePrimaryValue(event.value);\n\t        case ERROR:\n\t          return this._handlePrimaryError(event.value);\n\t        case END:\n\t          return this._handlePrimaryEnd(event.value);\n\t      }\n\t    },\n\t    _handleSecondaryAny: function (event) {\n\t      switch (event.type) {\n\t        case VALUE:\n\t          return this._handleSecondaryValue(event.value);\n\t        case ERROR:\n\t          return this._handleSecondaryError(event.value);\n\t        case END:\n\t          this._handleSecondaryEnd(event.value);\n\t          this._removeSecondary();\n\t      }\n\t    },\n\t    _removeSecondary: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.offAny(this._$handleSecondaryAny);\n\t        this._$handleSecondaryAny = null;\n\t        this._secondary = null;\n\t      }\n\t    },\n\t    _onActivation: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.onAny(this._$handleSecondaryAny);\n\t      }\n\t      if (this._active) {\n\t        this._primary.onAny(this._$handlePrimaryAny);\n\t      }\n\t    },\n\t    _onDeactivation: function () {\n\t      if (this._secondary !== null) {\n\t        this._secondary.offAny(this._$handleSecondaryAny);\n\t      }\n\t      this._primary.offAny(this._$handlePrimaryAny);\n\t    },\n\t    _clear: function () {\n\t      BaseClass.prototype._clear.call(this);\n\t      this._primary = null;\n\t      this._secondary = null;\n\t      this._lastSecondary = null;\n\t      this._$handleSecondaryAny = null;\n\t      this._$handlePrimaryAny = null;\n\t      this._free();\n\t    }\n\t  };\n\t}\n\n\tfunction createStream$1(name, mixin) {\n\t  var S = createConstructor$1(Stream, name);\n\t  inherit(S, Stream, createClassMethods$1(Stream), mixin);\n\t  return S;\n\t}\n\n\tfunction createProperty$1(name, mixin) {\n\t  var P = createConstructor$1(Property, name);\n\t  inherit(P, Property, createClassMethods$1(Property), mixin);\n\t  return P;\n\t}\n\n\tvar mixin$26 = {\n\t  _handlePrimaryValue: function (x) {\n\t    if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$34 = createStream$1('filterBy', mixin$26);\n\tvar P$29 = createProperty$1('filterBy', mixin$26);\n\n\tfunction filterBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n\t}\n\n\tvar id2 = function (_, x) {\n\t  return x;\n\t};\n\n\tfunction sampledBy(passive, active, combinator) {\n\t  var _combinator = combinator ? function (a, b) {\n\t    return combinator(b, a);\n\t  } : id2;\n\t  return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n\t}\n\n\tvar mixin$27 = {\n\t  _handlePrimaryValue: function (x) {\n\t    if (this._lastSecondary !== NOTHING) {\n\t      this._emitValue(x);\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (this._lastSecondary === NOTHING) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$35 = createStream$1('skipUntilBy', mixin$27);\n\tvar P$30 = createProperty$1('skipUntilBy', mixin$27);\n\n\tfunction skipUntilBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n\t}\n\n\tvar mixin$28 = {\n\t  _handleSecondaryValue: function () {\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$36 = createStream$1('takeUntilBy', mixin$28);\n\tvar P$31 = createProperty$1('takeUntilBy', mixin$28);\n\n\tfunction takeUntilBy(primary, secondary) {\n\t  return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n\t}\n\n\tvar mixin$29 = {\n\t  _init: function () {\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$flushOnEnd = _ref.flushOnEnd,\n\t        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n\t    this._buff = [];\n\t    this._flushOnEnd = flushOnEnd;\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handlePrimaryEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _onActivation: function () {\n\t    this._primary.onAny(this._$handlePrimaryAny);\n\t    if (this._alive && this._secondary !== null) {\n\t      this._secondary.onAny(this._$handleSecondaryAny);\n\t    }\n\t  },\n\t  _handlePrimaryValue: function (x) {\n\t    this._buff.push(x);\n\t  },\n\t  _handleSecondaryValue: function () {\n\t    this._flush();\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (!this._flushOnEnd) {\n\t      this._emitEnd();\n\t    }\n\t  }\n\t};\n\n\tvar S$37 = createStream$1('bufferBy', mixin$29);\n\tvar P$32 = createProperty$1('bufferBy', mixin$29);\n\n\tfunction bufferBy(primary, secondary, options /* optional */) {\n\t  return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n\t}\n\n\tvar mixin$30 = {\n\t  _init: function () {\n\t    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n\t        _ref$flushOnEnd = _ref.flushOnEnd,\n\t        flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd,\n\t        _ref$flushOnChange = _ref.flushOnChange,\n\t        flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n\t    this._buff = [];\n\t    this._flushOnEnd = flushOnEnd;\n\t    this._flushOnChange = flushOnChange;\n\t  },\n\t  _free: function () {\n\t    this._buff = null;\n\t  },\n\t  _flush: function () {\n\t    if (this._buff !== null) {\n\t      this._emitValue(this._buff);\n\t      this._buff = [];\n\t    }\n\t  },\n\t  _handlePrimaryEnd: function () {\n\t    if (this._flushOnEnd) {\n\t      this._flush();\n\t    }\n\t    this._emitEnd();\n\t  },\n\t  _handlePrimaryValue: function (x) {\n\t    this._buff.push(x);\n\t    if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n\t      this._flush();\n\t    }\n\t  },\n\t  _handleSecondaryEnd: function () {\n\t    if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n\t      this._emitEnd();\n\t    }\n\t  },\n\t  _handleSecondaryValue: function (x) {\n\t    if (this._flushOnChange && !x) {\n\t      this._flush();\n\t    }\n\n\t    // from default _handleSecondaryValue\n\t    this._lastSecondary = x;\n\t  }\n\t};\n\n\tvar S$38 = createStream$1('bufferWhileBy', mixin$30);\n\tvar P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\n\tfunction bufferWhileBy(primary, secondary, options /* optional */) {\n\t  return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n\t}\n\n\tvar f = function () {\n\t  return false;\n\t};\n\tvar t = function () {\n\t  return true;\n\t};\n\n\tfunction awaiting(a, b) {\n\t  var result = merge([map$1(a, t), map$1(b, f)]);\n\t  result = skipDuplicates(result);\n\t  result = toProperty(result, f);\n\t  return result.setName(a, 'awaiting');\n\t}\n\n\tvar mixin$31 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleValue: function (x) {\n\t    var fn = this._fn;\n\t    var result = fn(x);\n\t    if (result.convert) {\n\t      this._emitError(result.error);\n\t    } else {\n\t      this._emitValue(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$39 = createStream('valuesToErrors', mixin$31);\n\tvar P$34 = createProperty('valuesToErrors', mixin$31);\n\n\tvar defFn = function (x) {\n\t  return { convert: true, error: x };\n\t};\n\n\tfunction valuesToErrors(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn;\n\n\t  return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n\t}\n\n\tvar mixin$32 = {\n\t  _init: function (_ref) {\n\t    var fn = _ref.fn;\n\n\t    this._fn = fn;\n\t  },\n\t  _free: function () {\n\t    this._fn = null;\n\t  },\n\t  _handleError: function (x) {\n\t    var fn = this._fn;\n\t    var result = fn(x);\n\t    if (result.convert) {\n\t      this._emitValue(result.value);\n\t    } else {\n\t      this._emitError(x);\n\t    }\n\t  }\n\t};\n\n\tvar S$40 = createStream('errorsToValues', mixin$32);\n\tvar P$35 = createProperty('errorsToValues', mixin$32);\n\n\tvar defFn$1 = function (x) {\n\t  return { convert: true, value: x };\n\t};\n\n\tfunction errorsToValues(obs) {\n\t  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defFn$1;\n\n\t  return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n\t}\n\n\tvar mixin$33 = {\n\t  _handleError: function (x) {\n\t    this._emitError(x);\n\t    this._emitEnd();\n\t  }\n\t};\n\n\tvar S$41 = createStream('endOnError', mixin$33);\n\tvar P$36 = createProperty('endOnError', mixin$33);\n\n\tfunction endOnError(obs) {\n\t  return new (obs._ofSameType(S$41, P$36))(obs);\n\t}\n\n\tObservable.prototype.toProperty = function (fn) {\n\t  return toProperty(this, fn);\n\t};\n\n\tObservable.prototype.changes = function () {\n\t  return changes(this);\n\t};\n\n\tObservable.prototype.toPromise = function (Promise) {\n\t  return toPromise(this, Promise);\n\t};\n\n\tObservable.prototype.toESObservable = toESObservable;\n\tObservable.prototype[$$observable] = toESObservable;\n\n\tObservable.prototype.map = function (fn) {\n\t  return map$1(this, fn);\n\t};\n\n\tObservable.prototype.filter = function (fn) {\n\t  return filter(this, fn);\n\t};\n\n\tObservable.prototype.take = function (n) {\n\t  return take(this, n);\n\t};\n\n\tObservable.prototype.takeErrors = function (n) {\n\t  return takeErrors(this, n);\n\t};\n\n\tObservable.prototype.takeWhile = function (fn) {\n\t  return takeWhile(this, fn);\n\t};\n\n\tObservable.prototype.last = function () {\n\t  return last(this);\n\t};\n\n\tObservable.prototype.skip = function (n) {\n\t  return skip(this, n);\n\t};\n\n\tObservable.prototype.skipWhile = function (fn) {\n\t  return skipWhile(this, fn);\n\t};\n\n\tObservable.prototype.skipDuplicates = function (fn) {\n\t  return skipDuplicates(this, fn);\n\t};\n\n\tObservable.prototype.diff = function (fn, seed) {\n\t  return diff(this, fn, seed);\n\t};\n\n\tObservable.prototype.scan = function (fn, seed) {\n\t  return scan(this, fn, seed);\n\t};\n\n\tObservable.prototype.flatten = function (fn) {\n\t  return flatten(this, fn);\n\t};\n\n\tObservable.prototype.delay = function (wait) {\n\t  return delay(this, wait);\n\t};\n\n\tObservable.prototype.throttle = function (wait, options) {\n\t  return throttle(this, wait, options);\n\t};\n\n\tObservable.prototype.debounce = function (wait, options) {\n\t  return debounce(this, wait, options);\n\t};\n\n\tObservable.prototype.mapErrors = function (fn) {\n\t  return mapErrors(this, fn);\n\t};\n\n\tObservable.prototype.filterErrors = function (fn) {\n\t  return filterErrors(this, fn);\n\t};\n\n\tObservable.prototype.ignoreValues = function () {\n\t  return ignoreValues(this);\n\t};\n\n\tObservable.prototype.ignoreErrors = function () {\n\t  return ignoreErrors(this);\n\t};\n\n\tObservable.prototype.ignoreEnd = function () {\n\t  return ignoreEnd(this);\n\t};\n\n\tObservable.prototype.beforeEnd = function (fn) {\n\t  return beforeEnd(this, fn);\n\t};\n\n\tObservable.prototype.slidingWindow = function (max, min) {\n\t  return slidingWindow(this, max, min);\n\t};\n\n\tObservable.prototype.bufferWhile = function (fn, options) {\n\t  return bufferWhile(this, fn, options);\n\t};\n\n\tObservable.prototype.bufferWithCount = function (count, options) {\n\t  return bufferWhile$1(this, count, options);\n\t};\n\n\tObservable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n\t  return bufferWithTimeOrCount(this, wait, count, options);\n\t};\n\n\tObservable.prototype.transduce = function (transducer) {\n\t  return transduce(this, transducer);\n\t};\n\n\tObservable.prototype.withHandler = function (fn) {\n\t  return withHandler(this, fn);\n\t};\n\n\tObservable.prototype.combine = function (other, combinator) {\n\t  return combine([this, other], combinator);\n\t};\n\n\tObservable.prototype.zip = function (other, combinator) {\n\t  return zip([this, other], combinator);\n\t};\n\n\tObservable.prototype.merge = function (other) {\n\t  return merge([this, other]);\n\t};\n\n\tObservable.prototype.concat = function (other) {\n\t  return concat$1([this, other]);\n\t};\n\n\tvar pool = function () {\n\t  return new Pool();\n\t};\n\n\tObservable.prototype.flatMap = function (fn) {\n\t  return new FlatMap(this, fn).setName(this, 'flatMap');\n\t};\n\tObservable.prototype.flatMapLatest = function (fn) {\n\t  return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n\t};\n\tObservable.prototype.flatMapFirst = function (fn) {\n\t  return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n\t};\n\tObservable.prototype.flatMapConcat = function (fn) {\n\t  return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n\t};\n\tObservable.prototype.flatMapConcurLimit = function (fn, limit) {\n\t  return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n\t};\n\n\tObservable.prototype.flatMapErrors = function (fn) {\n\t  return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n\t};\n\n\tObservable.prototype.filterBy = function (other) {\n\t  return filterBy(this, other);\n\t};\n\n\tObservable.prototype.sampledBy = function (other, combinator) {\n\t  return sampledBy(this, other, combinator);\n\t};\n\n\tObservable.prototype.skipUntilBy = function (other) {\n\t  return skipUntilBy(this, other);\n\t};\n\n\tObservable.prototype.takeUntilBy = function (other) {\n\t  return takeUntilBy(this, other);\n\t};\n\n\tObservable.prototype.bufferBy = function (other, options) {\n\t  return bufferBy(this, other, options);\n\t};\n\n\tObservable.prototype.bufferWhileBy = function (other, options) {\n\t  return bufferWhileBy(this, other, options);\n\t};\n\n\t// Deprecated\n\t// -----------------------------------------------------------------------------\n\n\tvar DEPRECATION_WARNINGS = true;\n\tfunction dissableDeprecationWarnings() {\n\t  DEPRECATION_WARNINGS = false;\n\t}\n\n\tfunction warn(msg) {\n\t  if (DEPRECATION_WARNINGS && console && typeof console.warn === 'function') {\n\t    var msg2 = '\\nHere is an Error object for you containing the call stack:';\n\t    console.warn(msg, msg2, new Error());\n\t  }\n\t}\n\n\tObservable.prototype.awaiting = function (other) {\n\t  warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');\n\t  return awaiting(this, other);\n\t};\n\n\tObservable.prototype.valuesToErrors = function (fn) {\n\t  warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');\n\t  return valuesToErrors(this, fn);\n\t};\n\n\tObservable.prototype.errorsToValues = function (fn) {\n\t  warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');\n\t  return errorsToValues(this, fn);\n\t};\n\n\tObservable.prototype.endOnError = function () {\n\t  warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');\n\t  return endOnError(this);\n\t};\n\n\t// Exports\n\t// --------------------------------------------------------------------------\n\n\tvar Kefir = { Observable: Observable, Stream: Stream, Property: Property, never: never, later: later, interval: interval, sequentially: sequentially,\n\t  fromPoll: fromPoll, withInterval: withInterval, fromCallback: fromCallback, fromNodeCallback: fromNodeCallback, fromEvents: fromEvents, stream: stream,\n\t  constant: constant, constantError: constantError, fromPromise: fromPromise, fromESObservable: fromESObservable, combine: combine, zip: zip, merge: merge,\n\t  concat: concat$1, Pool: Pool, pool: pool, repeat: repeat, staticLand: staticLand };\n\n\tKefir.Kefir = Kefir;\n\n\texports.dissableDeprecationWarnings = dissableDeprecationWarnings;\n\texports.Kefir = Kefir;\n\texports.Observable = Observable;\n\texports.Stream = Stream;\n\texports.Property = Property;\n\texports.never = never;\n\texports.later = later;\n\texports.interval = interval;\n\texports.sequentially = sequentially;\n\texports.fromPoll = fromPoll;\n\texports.withInterval = withInterval;\n\texports.fromCallback = fromCallback;\n\texports.fromNodeCallback = fromNodeCallback;\n\texports.fromEvents = fromEvents;\n\texports.stream = stream;\n\texports.constant = constant;\n\texports.constantError = constantError;\n\texports.fromPromise = fromPromise;\n\texports.fromESObservable = fromESObservable;\n\texports.combine = combine;\n\texports.zip = zip;\n\texports.merge = merge;\n\texports.concat = concat$1;\n\texports.Pool = Pool;\n\texports.pool = pool;\n\texports.repeat = repeat;\n\texports.staticLand = staticLand;\n\texports['default'] = Kefir;\n\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/kefir/dist/kefir.js\n// module id = 2\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}